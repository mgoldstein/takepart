<?php

function features_conflict_resolver_get_cmap() {

  $conflicts = features_get_conflicts();

  $rmap = array();
  $cmap = array();

  foreach ($conflicts as $cm1 => $var) {
    foreach ($var as $cm2 => $var2) {
      foreach ($var2 as $type => $var3) {
        foreach ($var3 as $val) {
          $rmap[$type][$val]['modules'][$cm2] = TRUE;
        }
      }
    }
  }

  foreach ($rmap as $type => $var) {
    foreach ($var as $val => $var2) {
      $hash = md5(serialize($var2['modules']));
      $rmap[$type][$val]['hash'] = $hash;
      $cmap[$hash]['all-conflicts'][$val] = TRUE;
      $cmap[$hash]['conflicts'][$type][] = $val;
      $cmap[$hash]['modules'] = array_keys($var2['modules']);
      $cmap[$hash]['hash'] = $hash;
    }
  }

  return $cmap;
}

/**
 * Most code copied from drush.inc
 */
function _features_conflict_resolver_create_feature($stub, $dependencies, $module_name, $directory) {
  module_load_include('inc', 'features', 'features.export');
  $export = features_populate($stub, $dependencies, $module_name);
  if (!feature_load($module_name)) {
    $export['name'] = $module_name;
  }
  $files = features_export_render($export, $module_name, TRUE);

  foreach ($files as $extension => $file_contents) {
    if (!in_array($extension, array('module', 'info'))) {
      $extension .= '.inc';
    }
    file_put_contents("$directory/$module_name.$extension", $file_contents);
  }
}

/**
 * Create new feature that is holding the conflicting components.
 */
function features_conflict_resolver_create_feature($cmap_entry) {
 
  // @todo: Is this really necessary? 
  //drupal_flush_all_caches();

  $module_name = 'feature_' . $cmap_entry['hash'];
  $dependencies = array();
  $dirname = 'sites/all/modules/conflicts/' . $module_name;
  @mkdir($dirname);
  
  $all_conflicts = array(); 
  foreach ($cmap_entry['all-conflicts'] as $component => $val) {
    $all_conflicts[$component] = '';
  }

  $dummy = array();
  features_conflict_resolver_update_ctools_export_cache($dummy, $all_conflicts);

  _features_conflict_resolver_create_feature($cmap_entry['conflicts'], $dependencies, $module_name, $dirname);
  module_enable(array($module_name));
  drupal_flush_all_caches();
}

/**
 * Remove the conflicting components from the older features
 */
function features_conflict_resolver_update_feature($cmap_entry) {

  // @todo: Is this really necessary? 
  //drupal_flush_all_caches();
  $module_name = 'feature_' . $cmap_entry['hash'];

  $all_conflicts = array();
  foreach ($cmap_entry['all-conflicts'] as $component => $val) {
    $all_conflicts[$component] = $module_name;
  }

  $dummy = array();
  features_conflict_resolver_update_ctools_export_cache($dummy, $all_conflicts);

  foreach ($cmap_entry['modules'] as $module) {
    // @todo: Make enabled / all modules configurable.
    if (($feature = feature_load($module, TRUE))) { // && module_exists($module)) {
      $features = $feature->info['features'];
      $dependencies = $feature->info['dependencies'];

      _features_conflict_resolver_create_feature($features, $dependencies, $feature->name, dirname($feature->filename));
    }
  }
}


function features_conflict_resolver_update_ctools_export_cache(&$cache, $update = FALSE) {
  $components = &drupal_static(__FUNCTION__);
  if (!isset($components)) {
    $components = array( 'comment_anonymous_audio' => '' );
  }

  if (!$cache && $update !== FALSE) {
    $components = $update;

    // Clear ctools cache
    module_load_include('inc', 'features', 'features.export');
    ctools_export_load_object_reset();
    return;
  }

  foreach ($components as $component => $value) {
    if ($value) {
      $cache[$component]->export_module = $value;
    } else {
      unset($cache[$component]->export_module);
    }
  }
}

/**
 * @todo: Need to implement all hooks for this to work ...
 */
function features_conflict_resolver_strongarm_alter(&$cache) {
  features_conflict_resolver_update_ctools_export_cache($cache);
}

/**
 * @todo: Need to dynamically implement the strongarm, etc. hooks
 */
/*
function features_conflict_resolver_module_implements_alter(&$implementations, $hook) {
  
}
*/
