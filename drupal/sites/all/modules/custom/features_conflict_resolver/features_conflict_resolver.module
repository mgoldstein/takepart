<?php

function features_conflict_resolver_get_cmap() {
  $conflicts = features_get_conflicts();

  $rmap = array();
  $cmap = array();

  foreach ($conflicts as $cm1 => $var) {
    foreach ($var as $cm2 => $var2) {
      foreach ($var2 as $type => $var3) {
        foreach ($var3 as $val) {
          $rmap[$type][$val]['modules'][$cm2] = TRUE;
        }
      }
    }
  }

  foreach ($rmap as $type => $var) {
    foreach ($var as $val => $var2) {
      $hash = md5(serialize($var2['modules']));
      $rmap[$type][$val]['hash'] = $hash;
      $cmap[$hash]['all-conflicts'][$val] = TRUE;
      $cmap[$hash]['conflicts'][$type][] = $val;
      $cmap[$hash]['modules'] = array_keys($var2['modules']);
      $cmap[$hash]['hash'] = $hash;
    }
  }

  return $cmap;
}

/**
 * Most code copied from drush.inc
 */
function _features_conflict_resolver_create_feature($stub, $dependencies, $module_name, $directory) {
  module_load_include('inc', 'features', 'features.export');
  $export = features_populate($stub, $dependencies, $module_name);
  if (!feature_load($module_name)) {
    $export['name'] = $module_name;
  }
  $files = features_export_render($export, $module_name, TRUE);

  foreach ($files as $extension => $file_contents) {
    if (!in_array($extension, array('module', 'info'))) {
      $extension .= '.inc';
    }
    file_put_contents("$directory/$module_name.$extension", $file_contents);
  }
}

/**
 * Create new feature that is holding the conflicting components.
 */
function features_conflict_resolver_create_feature($cmap_entry) {

  // @todo: Is this really necessary?
  //drupal_flush_all_caches();

  $module_name = 'feature_' . $cmap_entry['hash'];
  $dependencies = array();
  $dirname = 'sites/all/modules/conflicts/' . $module_name;
  @mkdir($dirname);

  $all_conflicts = array();
  foreach ($cmap_entry['all-conflicts'] as $component => $val) {
    $all_conflicts[$component] = '';
  }

  $dummy = array();
  features_conflict_resolver_update_ctools_export_cache($dummy, $all_conflicts);

  _features_conflict_resolver_create_feature($cmap_entry['conflicts'], $dependencies, $module_name, $dirname);
  module_enable(array($module_name));
  drupal_flush_all_caches();
}

/**
 * Remove the conflicting components from the older features
 */
function features_conflict_resolver_update_feature($cmap_entry) {

  // @todo: Is this really necessary?
  //drupal_flush_all_caches();
  $module_name = 'feature_' . $cmap_entry['hash'];

  $all_conflicts = array();
  foreach ($cmap_entry['all-conflicts'] as $component => $val) {
    $all_conflicts[$component] = $module_name;
  }

  $dummy = array();
  features_conflict_resolver_update_ctools_export_cache($dummy, $all_conflicts);

  foreach ($cmap_entry['modules'] as $module) {
    // @todo: Make enabled / all modules configurable.
    if (($feature = feature_load($module, TRUE))) { // && module_exists($module)) {
      $features = $feature->info['features'];
      $dependencies = $feature->info['dependencies'];

      _features_conflict_resolver_create_feature($features, $dependencies, $feature->name, dirname($feature->filename));
    }
  }
}


function features_conflict_resolver_update_ctools_export_cache(&$cache, $update = FALSE) {
  $components = &drupal_static(__FUNCTION__);
  if (!isset($components)) {
    $components = array( 'comment_anonymous_audio' => '' );
  }

  if (!$cache && $update !== FALSE) {
    $components = $update;

    // Clear ctools cache
    module_load_include('inc', 'features', 'features.export');
    ctools_export_load_object_reset();
    return;
  }

  foreach ($components as $component => $value) {
    if ($value) {
      $cache[$component]->export_module = $value;
    } else {
      unset($cache[$component]->export_module);
    }
  }
}

/**
 * @todo: Need to implement all hooks for this to work ...
 */
function features_conflict_resolver_strongarm_alter(&$cache) {
  features_conflict_resolver_update_ctools_export_cache($cache);
}

/**
 * @todo: Need to dynamically implement the strongarm, etc. hooks
 */
/*
function features_conflict_resolver_module_implements_alter(&$implementations, $hook) {

}
*/

/**
 * Merge the passed components into a new group.
 *
 * @param $cmap
 *   A conflict map, as generated by features_conflict_resolver_get_cmap().
 * @param $merge_components
 *   An array of components to merge into a new group.
 * @param $name
 *   Defaults to NULL. By default, the new group will receive an identifying
 *   hash key, similar to the rest of the conflict map. If you'd like to
 *   specify the key instead, pass its value in $name.
 * @param $inherit
 *   Defaults to FALSE. If a passed component is part of a group with other
 *   components, those other entries will be merged into the new group also.
 *
 * @return $merged_cmap
 */
function features_conflict_resolver_cmap_component_merge($cmap, $merge_components, $name = NULL, $inherit = FALSE) {
  $merged_group = array(
    'all-conflicts' => array(),
    'conflicts'     => array(),
    'modules'       => array(),
  );

  foreach ($merge_components as $merge_component) {
    $merged_group['all-conflicts'][$merge_component] = TRUE;

    foreach ($cmap as $hash => $group) {
      // If our desire is in this group, COMMENCE FIDDLING.
      if (isset($group['all-conflicts'][$merge_component])) {
        foreach ($group['conflicts'] as $component_type => $components) {
          foreach ($components as $index => $component) {
            if ($component == $merge_component) {

              if ($inherit) { // Merge all associated components into the new group.
                $merged_group['all-conflicts'] += $cmap[$hash]['all-conflicts'];
                $merged_group['conflicts'] = array_merge_recursive(
                  $merged_group['conflicts'], $cmap[$hash]['conflicts']);
                $cmap[$hash]['all-conflicts'] = array();
              }
              else { // Merge just the single component into the new group.
                $merged_group['conflicts'][$component_type][] = $merge_component;
                unset($cmap[$hash]['all-conflicts'][$merge_component]);
                unset($cmap[$hash]['conflicts'][$component_type][$index]);
              }

              // Add the modules this component is claimed by.
              $merged_group['modules'] = array_unique(array_merge(
                $merged_group['modules'], $cmap[$hash]['modules']));

              // If this hash has no more conflicts, delete it.
              if (count($cmap[$hash]['all-conflicts']) == 0) {
                unset($cmap[$hash]);
              }
            }
          }
        }
      }
    }
  }

  // We've got a merged group and a modified conflict map with old hashes.
  // Recreate the conflict map with the new group and proper rehashes.
  $merged_group['hash'] = isset($name) ? $name : md5(serialize($merged_group['modules']));
  $merged_cmap = array($merged_group['hash'] => $merged_group);
  foreach ($cmap as $hash => $group) {
    if (strlen($hash) == 32) { // Regen only if md5ish.
      $group['hash'] = md5(serialize($group['modules']));
    }

    $merged_cmap[$group['hash']] = $group;
  }

  return $merged_cmap;
}





/**
 * Merge the passed modules into a new group.
 *
 * @param $cmap
 *   A conflict map, as generated by features_conflict_resolver_get_cmap().
 * @param $merge_modules
 *   An array of modules to merge into a new group.
 * @param $name
 *   Defaults to NULL. By default, the new group will receive an identifying
 *   hash key, similar to the rest of the conflict map. If you'd like to
 *   specify the key instead, pass its value in $name.
 *
 * @return $merged_cmap
 */
function features_conflict_resolver_cmap_module_merge($cmap, $merge_modules, $name = NULL) {
  $merged_group = array(
    'all-conflicts' => array(),
    'conflicts'     => array(),
    'modules'       => array(),
  );

  foreach ($merge_modules as $index => $merge_module) {
    $merged_group['modules'][] = $merge_module;

    foreach ($cmap as $hash => $group) {
      // If our desire is in this group, COMMENCE FIDDLING.
      if (in_array($merge_module, $group['modules'])) {
        $merged_group['all-conflicts'] += $cmap[$hash]['all-conflicts'];
        $merged_group['conflicts'] = array_merge_recursive($merged_group['conflicts'], $cmap[$hash]['conflicts']);
        unset($cmap[$hash]);
      }
    }
  }

  // We've got a merged group and a modified conflict map with old hashes.
  // Recreate the conflict map with the new group and proper rehashes.
  $merged_group['hash'] = isset($name) ? $name : md5(serialize($merged_group['modules']));
  $merged_cmap = array($merged_group['hash'] => $merged_group);
  foreach ($cmap as $hash => $group) {
    if (strlen($hash) == 32) { // Regen only if md5ish.
      $group['hash'] = md5(serialize($group['modules']));
    }

    $merged_cmap[$group['hash']] = $group;
  }

  return $merged_cmap;
}
