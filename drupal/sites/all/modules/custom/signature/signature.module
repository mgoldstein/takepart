<?php
/**
 * @file
 * Module for Signatures
 */

/**
 * Implements hook_help().
 */
function signature_help($path, $arg) {
  $output = '';
  if ($path == 'admin/help#signature') {
    $output .= '<h3>' . t('About') . '</h3>';
    $output .= '<p>' . t("The TakePart Signature module provides action data imports at regular intervals.") . '</p>';
  }
  return $output;
}

/* Entity
 ******************************************************************************/
/**
 * Implements hook_entity_info().
 */
function signature_entity_info() {

  $info = array();

  $info['signature_node'] = array(
    'label' => t('Signature Node Settings'),
    'entity class' => 'SignatureNode',
    'controller class' => 'SignatureNodeController',
    'base table' => 'signature_node',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'nid',
      'label' => 'title',
    ),
    'uri callback' => 'entity_class_uri',
    'access callback' => 'signature_access',
    'module' => 'signature',
  );

  return $info;
}


/* Access Control
 ******************************************************************************/
/**
 * Implements hook_permission().
 */
function signature_permission() {
  // Return permissions for the standard API entity operations.
  return array(
    'administer signature signature_node' => array(
      'title' => t('Administer Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'view signature signature_node' => array(
      'title' => t('View Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'update signature signature_node' => array(
      'title' => t('Update Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'create signature signature_node' => array(
      'title' => t('Create Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'delete signature signature_node' => array(
      'title' => t('Delete Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'signature configure import settings' => array(
      'title' => t('Configure action import settings'),
      'description' => t('Configure the donation action data import settings.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Access callback for signatures.
 */
function signature_access($op, $entity, $account, $entity_type) {
  // Block unknown operations.
  $allowed_ops = array('administer', 'view', 'update', 'create', 'delete');
  if (in_array($op, $allowed_ops)) {
    return user_access("$op signature $entity_type", $account)
      || user_access("administer signature $entity_type", $account);
  }
  return FALSE;
}


/* Menu
 ******************************************************************************/
/**
 * Implements hook_menu().
 */
function signature_menu() {
  return array(
    'admin/config/participant-media/action-import' => array(
      'title' => 'Action Import',
      'description' => 'Configuraion of donation action import',
      'weight' => 0,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('signature_import_admin_form'),
      'access callback' => 'user_access',
      'access arguments' => array('signature configure import settings'),
    ),
    'api/signature' => array(
      'page callback' => 'signature_api_create',
      'type' => MENU_CALLBACK,
      'access arguments' => array('access content'),
      'delivery callback' => 'signature_deliver_api_page',
    ),
  );
}


/* Theming
 ******************************************************************************/
/**
 * Implements hook_preprocess_field().
 */
function signature_preprocess_field(&$vars) {

  $field_name = $vars['element']['#field_name'];
  $view_mode = $vars['element']['#view_mode'];

  if ($field_name == 'field_action_type') {
    $object = $vars['element']['#object'];
    $type = $vars['element']['#entity_type'];
    $item = reset(field_get_items($type, $object, 'field_action_type'));
    if ($item !== FALSE && isset($item['taxonomy_term'])) {
      $action_type_class = 'action-type ' . $item['taxonomy_term']->name;
      $vars['classes_array'][] = drupal_html_class($action_type_class);
    }
  }
}

/**
 * Implements hook_preprocess_node().
 */
function signature_preprocess_node(&$vars) {
  $node = $vars['node'];
  $view_mode = $vars['view_mode'];
  $extra_classes = array(
    drupal_html_class('view-mode-' . $view_mode),
  );
  $vars['classes_array'] = array_merge($vars['classes_array'], $extra_classes);
}


/* Signature AJAX API.
 ******************************************************************************/
/**
 * Implements hook_node_delete().
 */
function signature_node_delete($node) {
  // Delete any existing node settings and field mapping.
  entity_delete('signature_node', $node->nid);
}

/**
 * Implements hook_entity_delete().
 */
function signature_entity_delete($entity, $type) {
  if ($type === 'signature_node') {
    // Delete the accompaning signup endpoint.
    if (!empty($entity->pm_signup_endpoint_id)) {
      SignatureSignupEndpoint::deleteByID($entity->pm_signup_endpoint_id);
    }
  }
}

function signature_deliver_api_page($page_callback_result) {
  drupal_add_http_header('Content-Type', 'application/json');
  drupal_add_http_header('Status', $page_callback_result['status']);
  print drupal_json_encode($page_callback_result['payload']);
}

function signature_api_create($nid) {

  // Creates are done through a POST
  if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    return array(
      'status' => '405 Method Not Allowed',
      'payload' => array(
        'errors' => array(
          'HTTP method must be POST.'
        ),
      ),
    );
  }

  // Request content type must be JSON
  if ($_SERVER['CONTENT_TYPE'] !== 'application/json') {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Invalid request content type.',
        ),
      ),
    );
  }

  // First (and only) path element is a nid
  if (!preg_match('/^[0-9]+$/', $nid)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Invalid action id.',
        ),
      ),
    );
  }

  // The nid must point to a valid node
  $node = node_load($nid);
  if ($node === FALSE) {
    return array(
      'status' => '404 Not Found',
      'payload' => array(
        'errors' => array(
          'No such action exists.',
        ),
      ),
    );
  }

  // The action must support signatures
  if (!signature_node_is_signature_action($node)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'The requested action does not support signatures.',
        ),
      ),
    );
  }

  // The action must has a signature configuration
  $settings = entity_load_single('signature_node', $nid);
  if ($settings === FALSE || empty($settings->pm_signup_endpoint_id)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'The requested action is not configured for signatures.',
        ),
      ),
    );
  }

  // Decode the JSON payload
  $body = file_get_contents('php://input');
  $request = drupal_json_decode($body);
  if (!isset($request)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Unable to decode request payload.',
        ),
      ),
    );
  }

  // Validate the payload
  $validation_errors = array();
  if (!isset($request['first_name'])) {
    $validation_errors[] = 'First name is required.';
  }
  if (!isset($request['last_name'])) {
    $validation_errors[] = 'Last name is required.';
  }
  if (!isset($request['email'])) {
    $validation_errors[] = 'Email is required.';
  }
  if (!isset($request['display_signature'])) {
    $validation_errors[] = 'Signature display flag is required.';
  }
  if (!isset($request['opt_ins'])) {
    $validation_errors[] = 'Opt-in list is required.';
  }
  if (!is_array($request['opt_ins'])) {
    $validation_errors[] = 'Opt-in list must be an array.';
  }
  if (!empty($validation_errors)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => $validation_errors,
      ),
    );
  }

  // Check that the email adress is in fact an email address
  if (!valid_email_address($request['email'])) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Invalid email address.',
        ),
      ),
    );
  }

  // Translate the request body to the standard signup format
  $payload = array(
    'email' => $request['email'],
    'name.first' => $request['first_name'],
    'name.last' => $request['last_name'],
    'action.id' => $nid,
    'action.signature-type' => 'international_signature',
    'action.opt-ins.display' => $request['display_signature'],
  );

  // Newsletter opt-ins
  $opt_ins = array(
    'opt_in_1' => 'false',
    'opt_in_2' => 'false',
    'opt_in_3' => 'false',
    'opt_in_4' => 'false',
    'opt_in_5' => 'false',
  );
  foreach ($request['opt_ins'] as $opt_in) {
    $name = $opt_in['name'];
    if (!empty($opt_in['value']) && isset($opt_ins[$name])) {
      $opt_ins[$name] = 'true';
    }
  }
  $payload['action.opt-ins.newsletters'] = implode(',', $opt_ins);

  // Address
  if (!empty($request['address'])) {
    $payload['address.address'] = $request['address'];
  }
  if (!empty($request['city'])) {
    $payload['address.city'] = $request['city'];
  }
  if (!empty($request['postal_code'])) {
    $payload['address.postal-code'] = $request['postal_code'];
  }
  if (!empty($request['country'])) {
    $payload['address.country'] = $request['country'];
  }

  // Addresses in the US can have a state and ZIP code
  if (empty($request['country']) || $request['country'] == 'United States') {
    if (!empty($request['state'])) {
      $payload['address.state.code'] = $request['state'];
    }
    if (!empty($request['postal_code'])) {
      $payload['address.postal-code.type'] = 'ZIP';
    }
  }

  // Custom message (of support)
  if (!empty($request['message'])) {
    $payload['action.message'] = $request['address'];
    $payload['action.signature-type'] = 'mos_action';
  }

  // Partner code and opt-in
  if (!empty($_REQUEST['partner_code'])) {
    $payload['partner.code'] = $_REQUEST['partner_code'];
    if (!empty($request['partner_opt_in'])) {
      $payload['action.opt-ins.partner'] = '1';
    }
  }

  // Send the signup
  $sent = pm_signup_handle(array(
    'type' => 'signature',
    'endpoint' => $nid,
    'payload' => $payload,
  ));

  if ($sent === 'duplicate') {
    return array(
      'status' => '409 Conflict',
      'payload' => array(
        'errors' => array(
          'Signature already exists.',
        ),
      ),
    );
  }
  elseif ($sent === FALSE) {
    return array(
      'status' => '500 Internal Server Error',
      'payload' => array(
        'errors' => array(
          'Signup submission failed.',
        ),
      ),
    );
  }

  return array(
    'status' => '201 Created',
    'payload' => array(
      'id' => 0xDeadBeef,
    ),
  );
}

/* Action Import
 ******************************************************************************/
/**
 * Admin form callback.
 */
function signature_import_admin_form($form, &$form_state) {

  $form['signature_import_feed'] = array(
    '#type' => 'textfield',
    '#title' => t('Feed'),
    '#description' => t('The full URL of the action data feed. Leave empty to disable imports.'),
    '#required' => FALSE,
    '#default_value' => variable_get('signature_import_feed', ''),
    '#element_validate' => array('pm_core_element_validate_url'),
  );

  $form['signature_import_interval'] = array(
    '#type' => 'textfield',
    '#title' => t('Inteval'),
    '#description' => t('The interval in minutes at which the feed should be imported.'),
    '#required' => FALSE,
    '#default_value' => variable_get('signature_import_interval', 5),
    '#element_validate' => array('element_validate_integer_positive'),
  );

  return system_settings_form($form);
}

/**
 * Implements hook_cron_queue_info().
 */
function signature_cron_queue_info() {
  return array(
    'signature_import_queue' => array(
      'worker callback' => 'signature_import_worker',
      'time' => 15,
    ),
  );
}

/**
 * Implements hook_cron().
 */
function signature_cron() {

  // Read the configuration.
  $feed_url = variable_get('signature_import_feed', '');
  $interval = ((int) variable_get('signature_import_interval', 5)) * 60;

  // Check that we have a workable configuration.
  if (!empty($feed_url) && $interval > 0) {

    // Get the last time cron ran.
    $cron_last = db_query("SELECT timestamp FROM {watchdog} WHERE type = 'cron' ORDER BY timestamp DESC LIMIT 1")
      ->fetchField();

    // If the interval has passed, get a list of updated actions and
    // queue them for import.
    if ($cron_last > 0 && (time() - $cron_last) > $interval) {

      // FIXME: Add in something that tracks the last time cron was run.
      //        It doesn't need to worry about acquiring a lock when setting the
      //        value, at most we update actions for two cron intervals this is
      //        still much better than updating all actions all the time.
      $actions = signature_read_import_feed($feed_url);
      $queue = DrupalQueue::get('signature_import_queue');
      foreach ($actions as $action) {
        // Process only donation actions.
        // FIXME: It would nice if the feed contained the actions last updated
        //        timestamp so we can further limit the queued actions to those
        //        that have been updated/created since the last cron run.
        $queue->createItem($action);
      }
    }
  }
}

/**
 * Reads the updated action feed.
 */
function signature_read_import_feed($feed_url) {

  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $feed_url);
  curl_setopt($ch, CURLOPT_TIMEOUT, 10);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);

  // Include the header in result.
  curl_setopt($ch, CURLOPT_HEADER, 1);

  // Make the request.
  try {
    $response = curl_exec($ch);
    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
  }
  catch (Exception $ex) {
    @curl_close($ch);
    $message = 'Unable to retrieve feed from [@url]';
    watchdog('signature', $message, array(
      '@endpoint' => $feed_url,
    ));
    // Nothing to queue.
    return array();
  }

  if ($http_code !== 200) {
    watchdog('signature', 'Error occurred while retrieving feed');
    // Nothing to queue.
    return array();
  }

  // Extract the response body.
  $header_length = curl_getinfo($ch, CURLINFO_HEADER_SIZE);
  $body = trim(substr($response, $header_length));

  @curl_close($ch);

  $data = json_decode($body);
  if (!isset($data)) {
    watchdog('signature', 'Unable to parse feed body');
    // Nothing to queue.
    return array();
  }

  return $data;
}

/**
 * Cron queue worker callback.
 *
 * @param StdClass $action
 *   An associative array containing the following:
 *   - action_id: the TAP-to-TakePart id of the action.
 *   - title: the title of the action.
 *   - url: the path of action on the site.
 *   - image_url: the URL of the action image.
 *   - type: the type of action.
 *   - topic: array of topic vocabulary terms for the action.
 */
function signature_import_worker($action) {

  // TODO: Actually create/update the action. This should use the
  //  signature_node table to determine if an action already has a
  //  stub in the database or if one needs to be created.

  // When creating an action set the type column of signature_node table to
  // the type attribute of the $action.

  // The signature_node table should also be used in the TakeAction
  // action overrided module to translate Drupal node ids to the TAP action id.

  // The reason for using the signature_node table and not creating
  // a new content type are:
  // - The action type already exists and is integrated into the various views
  //   and filters on the site, meaning no additional work has to be done to
  //   make TAP actions available to those views.
  // - It allows TAP to add any number of new action types, as long as the
  //   fields in the feed as constitent across all new action types.
  // - It doesn't require any wonky id mapping scheme (like picking an id well
  //   outside the existing node id range). Each system can simply use whatever
  //   auto-generated id they are provided by the framework.
}
