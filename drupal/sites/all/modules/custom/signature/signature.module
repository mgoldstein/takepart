<?php
/**
 * @file
 * Module for Signatures
 */

include_once dirname(__FILE__) . '/signature.mapping.conf.inc';

/* Entity
 ******************************************************************************/
/**
 * Implements hook_entity_info().
 */
function signature_entity_info() {

  $info = array();

  $info['signature_node'] = array(
    'label' => t('Signature Node Settings'),
    'entity class' => 'SignatureNode',
    'controller class' => 'SignatureNodeController',
    'base table' => 'signature_node',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'nid',
      'label' => 'title',
    ),
    'uri callback' => 'entity_class_uri',
    'access callback' => 'signature_access',
    'module' => 'signature',
  );

  return $info;
}


/* Access Control
 ******************************************************************************/
/**
 * Implements hook_permission().
 */
function signature_permission() {
  // Return permissions for the standard API entity operations.
  return array(
    'administer signature signature_node' => array(
      'title' => t('Administer Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'view signature signature_node' => array(
      'title' => t('View Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'update signature signature_node' => array(
      'title' => t('Update Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'create signature signature_node' => array(
      'title' => t('Create Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'delete signature signature_node' => array(
      'title' => t('Delete Signature Node Settings'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Access callback for signatures.
 */
function signature_access($op, $entity, $account, $entity_type) {
  // Block unknown operations.
  $allowed_ops = array('administer', 'view', 'update', 'create', 'delete');
  if (in_array($op, $allowed_ops)) {
    return user_access("$op signature $entity_type", $account)
      || user_access("administer signature $entity_type", $account);
  }
  return FALSE;
}


/* Menu
 ******************************************************************************/
/**
 * Implements hook_menu().
 */
function signature_menu() {
  return array(
    'api/signature' => array(
      'page callback' => 'signature_api_create',
      'type' => MENU_CALLBACK,
      'access arguments' => array('access content'),
      'delivery callback' => 'signature_deliver_api_page',
    ),
  );
}


/* Theming
 ******************************************************************************/
/**
 * Implements hook_preprocess_field().
 */
function signature_preprocess_field(&$vars) {

  $field_name = $vars['element']['#field_name'];
  $view_mode = $vars['element']['#view_mode'];

  if ($field_name == 'field_action_type') {
    $object = $vars['element']['#object'];
    $type = $vars['element']['#entity_type'];
    $item = reset(field_get_items($type, $object, 'field_action_type'));
    if ($item !== FALSE && isset($item['taxonomy_term'])) {
      $action_type_class = 'action-type ' . $item['taxonomy_term']->name;
      $vars['classes_array'][] = drupal_html_class($action_type_class);
    }
  }
}

/**
 * Implements hook_preprocess_node().
 */
function signature_preprocess_node(&$vars) {
  $node = $vars['node'];
  $view_mode = $vars['view_mode'];
  $extra_classes = array(
    drupal_html_class('view-mode-' . $view_mode),
  );
  $vars['classes_array'] = array_merge($vars['classes_array'], $extra_classes);
}


/* Signature AJAX API.
 ******************************************************************************/
/**
 * Implements hook_node_delete().
 */
function signature_node_delete($node) {
  // Delete any existing node settings and field mapping.
  entity_delete('signature_node', $node->nid);
}

/**
 * Implements hook_entity_delete().
 */
function signature_entity_delete($entity, $type) {
  if ($type === 'signature_node') {
    // Delete the accompaning signup endpoint.
    if (!empty($entity->pm_signup_endpoint_id)) {
      SignatureSignupEndpoint::deleteByID($entity->pm_signup_endpoint_id);
    }
  }
}

function signature_deliver_api_page($page_callback_result) {
  drupal_add_http_header('Content-Type', 'application/json');
  drupal_add_http_header('Status', $page_callback_result['status']);
  print drupal_json_encode($page_callback_result['payload']);
}

function signature_api_create($nid) {

  // Creates are done through a POST
  if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    return array(
      'status' => '405 Method Not Allowed',
      'payload' => array(
        'errors' => array(
          'HTTP method must be POST.'
        ),
      ),
    );
  }

  // Request content type must be JSON
  if ($_SERVER['CONTENT_TYPE'] !== 'application/json') {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Invalid request content type.',
        ),
      ),
    );
  }

  // First (and only) path element is a nid
  if (!preg_match('/^[0-9]+$/', $nid)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Invalid action id.',
        ),
      ),
    );
  }

  // The nid must point to a valid node
  $node = node_load($nid);
  if ($node === FALSE) {
    return array(
      'status' => '404 Not Found',
      'payload' => array(
        'errors' => array(
          'No such action exists.',
        ),
      ),
    );
  }

  // The action must support signatures
  if (!signature_node_is_signature_action($node)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'The requested action does not support signatures.',
        ),
      ),
    );
  }

  // The action must has a signature configuration
  $settings = entity_load_single('signature_node', $nid);
  if ($settings === FALSE || empty($settings->pm_signup_endpoint_id)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'The requested action is not configured for signatures.',
        ),
      ),
    );
  }

  // Decode the JSON payload
  $body = file_get_contents('php://input');
  $request = drupal_json_decode($body);
  if (!isset($request)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Unable to decode request payload.',
        ),
      ),
    );
  }

  // Validate the payload
  $validation_errors = array();
  if (!isset($request['first_name'])) {
    $validation_errors[] = 'First name is required.';
  }
  if (!isset($request['last_name'])) {
    $validation_errors[] = 'Last name is required.';
  }
  if (!isset($request['email'])) {
    $validation_errors[] = 'Email is required.';
  }
  if (!isset($request['display_signature'])) {
    $validation_errors[] = 'Signature display flag is required.';
  }
  if (!isset($request['opt_ins'])) {
    $validation_errors[] = 'Opt-in list is required.';
  }
  if (!is_array($request['opt_ins'])) {
    $validation_errors[] = 'Opt-in list must be an array.';
  }
  if (!empty($validation_errors)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => $validation_errors,
      ),
    );
  }

  // Check that the email adress is in fact an email address
  if (!valid_email_address($request['email'])) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Invalid email address.',
        ),
      ),
    );
  }

  // Translate the request body to the standard signup format
  $payload = array(
    'email' => $request['email'],
    'name.first' => $request['first_name'],
    'name.last' => $request['last_name'],
    'action.id' => $nid,
    'action.signature-type' => 'international_signature',
    'action.opt-ins.display' => $request['display_signature'],
  );

  // Newsletter opt-ins
  $opt_ins = array(
    'opt_in_1' => 'false',
    'opt_in_2' => 'false',
    'opt_in_3' => 'false',
    'opt_in_4' => 'false',
    'opt_in_5' => 'false',
  );
  foreach ($request['opt_ins'] as $opt_in) {
    $name = $opt_in['name'];
    if (!empty($opt_in['value']) && isset($opt_ins[$name])) {
      $opt_ins[$name] = 'true';
    }
  }
  $payload['action.opt-ins.newsletters'] = implode(',', $opt_ins);

  // Address
  if (!empty($request['address'])) {
    $payload['address.address'] = $request['address'];
  }
  if (!empty($request['city'])) {
    $payload['address.city'] = $request['city'];
  }
  if (!empty($request['postal_code'])) {
    $payload['address.postal-code'] = $request['postal_code'];
  }
  if (!empty($request['country'])) {
    $payload['address.country'] = $request['country'];
  }

  // Addresses in the US can have a state and ZIP code
  if (empty($request['country']) || $request['country'] == 'United States') {
    if (!empty($request['state'])) {
      $payload['address.state.code'] = $request['state'];
    }
    if (!empty($request['postal_code'])) {
      $payload['address.postal-code.type'] = 'ZIP';
    }
  }

  // Custom message (of support)
  if (!empty($request['message'])) {
    $payload['action.message'] = $request['address'];
    $payload['action.signature-type'] = 'mos_action';
  }

  // Partner code and opt-in
  if (!empty($_REQUEST['partner_code'])) {
    $payload['partner.code'] = $_REQUEST['partner_code'];
    if (!empty($request['partner_opt_in'])) {
      $payload['action.opt-ins.partner'] = '1';
    }
  }

  // Send the signup
  $sent = pm_signup_handle(array(
    'type' => 'signature',
    'endpoint' => $nid,
    'payload' => $payload,
  ));

  if ($sent === 'duplicate') {
    return array(
      'status' => '409 Conflict',
      'payload' => array(
        'errors' => array(
          'Signature already exists.',
        ),
      ),
    );
  }
  elseif ($sent === FALSE) {
    return array(
      'status' => '500 Internal Server Error',
      'payload' => array(
        'errors' => array(
          'Signup submission failed.',
        ),
      ),
    );
  }

  return array(
    'status' => '201 Created',
    'payload' => array(
      'id' => 0xDeadBeef,
    ),
  );
}
