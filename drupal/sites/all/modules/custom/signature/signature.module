<?php
/**
 * @file
 * Module for Signatures
 */

include_once dirname(__FILE__) . '/signature.mapping.conf.inc';

/* Entity
 ******************************************************************************/
/**
 * Implements hook_entity_info().
 */
function signature_entity_info() {

  $info = array();

  $info['signature_node'] = array(
    'label' => t('Signature Node Settings'),
    'entity class' => 'SignatureNode',
    'controller class' => 'SignatureNodeController',
    'base table' => 'signature_node',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'nid',
      'label' => 'title',
    ),
    'uri callback' => 'entity_class_uri',
    'access callback' => 'signature_access',
    'module' => 'signature',
  );

  return $info;
}


/* Access Control
 ******************************************************************************/
/**
 * Implements hook_permission().
 */
function signature_permission() {
  // Return permissions for the standard API entity operations.
  return array(
    'administer signature signature_node' => array(
      'title' => t('Administer Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'view signature signature_node' => array(
      'title' => t('View Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'update signature signature_node' => array(
      'title' => t('Update Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'create signature signature_node' => array(
      'title' => t('Create Signature Node Settings'),
      'restrict access' => TRUE,
    ),
    'delete signature signature_node' => array(
      'title' => t('Delete Signature Node Settings'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Access callback for signatures.
 */
function signature_access($op, $entity, $account, $entity_type) {
  // Block unknown operations.
  $allowed_ops = array('administer', 'view', 'update', 'create', 'delete');
  if (in_array($op, $allowed_ops)) {
    return user_access("$op signature $entity_type", $account)
      || user_access("administer signature $entity_type", $account);
  }
  return FALSE;
}


/* Node Type Configuration
 ******************************************************************************/
/**
 * Implements hook_menu().
 */
function signature_menu() {
  return array(
    'api/signature' => array(
      'page callback' => 'signature_api_create',
      'type' => MENU_CALLBACK,
      'access arguments' => array('access content'),
      'delivery callback' => 'signature_deliver_api_page',
    ),
  );
}

/**
 * Helper function for determining if a node collects signatures.
 */
function signature_node_is_signature_action($node) {
  return in_array($node->type, array('petition_action', 'pledge_action', 'mos_action'));
}


/* Node Configuration
 ******************************************************************************/
/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function signature_form_node_form_alter(&$form, &$form_state) {

  $node = $form['#node'];
  if (signature_node_is_signature_action($node)) {

    // Get the field values from the appropriate source.
    $values = signature_node_form_values($form, $form_state);
    $node->signature_settings_present = TRUE;

    $js_path = drupal_get_path('module', 'signature')
      . '/js/signature-vertical-tabs.js';
    $form['signature'] = array(
      '#title' => t('Signature settings'),
      '#type' => 'fieldset',
      '#group' => 'additional_settings',
      '#attributes' => array('class' => array('edit-signature')),
      '#attached' => array('js' => array('vertical-tabs' => $js_path)),
    );

    $form['signature']['signature_bsd_form']
      = bluestatedigital_forms_signup_form_id($values->bsd_form);

    $options = array('' => t('<No Signatures>'));
    foreach (signature_type_load() as $name => $type) {
      $options[$name] = $type->label;
    }
    $form['signature']['signature_type'] = array(
      '#title' => t('Signature Type'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => $values->type,
    );

    $form['signature']['signature_goal'] = array(
      '#title' => t('Signature Goal'),
      '#description' => t('The target number of signatures.'),
      '#type' => 'textfield',
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required' => TRUE,
      '#default_value' => $values->goal,
    );

    $form['signature']['limit_range'] = array(
      '#title' => t('Date Range'),
      '#type' => 'fieldset',
    );

    $form['signature']['limit_range']['signature_limit_to_dates'] = array(
      '#title' => t('Limit signatures to the following date range.'),
      '#type' => 'checkbox',
      '#default_value' => $values->limit_to_dates,
    );

    $form['signature']['limit_range']['signature_start_date'] = array(
      '#title' => t('Start Date'),
      '#description' => t('The start date of the range.'),
      '#type' => 'date',
      '#default_value' => signature_timestamp_to_date($values->start_date),
    );

    $form['signature']['limit_range']['signature_end_date'] = array(
      '#title' => t('End Date'),
      '#description' => t('The end date of the range.'),
      '#type' => 'date',
      '#default_value' => signature_timestamp_to_date($values->end_date),
    );

    $form['signature']['signature_restrictions'] = array(
      '#title' => t('Restrictions note'),
      '#description' => t('Text of note indicating any restrictions on who can sign. If this field is left empty, no note will be shown.'),
      '#type' => 'textfield',
      '#maxlength' => 255,
      '#default_value' => $values->restrictions,
    );

    $form['signature']['signature_terms_of_use'] = array(
      '#title' => t('Terms of use note'),
      '#description' => t("Text of note indicating that the user accepts the TakePart Terms of use by signing."),
      '#type' => 'textfield',
      '#maxlength' => 255,
      '#default_value' => $values->terms_of_use,
    );

    $form['signature']['signature_display_disclaimer'] = array(
      '#title' => t('Signature display disclaimer'),
      '#description' => t("Text of disclaimer regarding the public sharing of the user's signature."),
      '#type' => 'textfield',
      '#maxlength' => 255,
      '#default_value' => $values->display_disclaimer,
    );

    $form['signature']['signature_sign_label'] = array(
      '#title' => t('Sign Button Label'),
      '#description' => t('The label to use on the sign button.'),
      '#type' => 'textfield',
      '#default_value' => $values->sign_label,
    );

    $form['signature_newsletters'] = array(
      '#title' => t('Newsletter opt-ins'),
      '#type' => 'fieldset',
      '#group' => 'additional_settings',
      '#attributes' => array('class' => array('edit-signature-newsletters')),
    );

    $form['signature_newsletters']['notice'] = array(
      '#type' => 'markup',
      '#markup' => t("<strong>In order to collect email opt-ins, the newsletter must be set on the signup form in BSD (Step 2: Edit Form Fields in the manage signup form admin). The fields below only control the opt-in copy and the analytics newsletter name (for reporting purposes).</strong>"),
    );

    $ordinals = array('first', 'second', 'third', 'fourth', 'fifth');
    foreach ($ordinals as $num => $ord) {

      $label_name = sprintf('signature_newsletter_label_%d', $num);
      $group_name = sprintf('signature_newsletter_group_%d', $num);

      if (!empty($values->newsletter_opt_ins[$num])) {
        $label_value = $values->newsletter_opt_ins[$num]['label'];
        $group_value = $values->newsletter_opt_ins[$num]['group'];
      }
      else {
        $label_value = '';
        $group_value = '';
      }

      $form['signature_newsletters'][$ord] = array(
        '#title' => t('Newsletter @num', array('@num' => $num + 1)),
        '#type' => 'fieldset',
        '#collapsible' => TRUE,
        '#collapsed' => ($num != 0) && empty($label_value),
      );

      $form['signature_newsletters'][$ord][$label_name] = array(
        '#title' => t('Newsletter Opt-In Label'),
        '#description' => t('The label to use for the newsletter opt-in. If this field is left empty, no newsletter opt-in field will be shown.'),
        '#type' => 'textfield',
        '#attributes' => array(
          'class' => array('signature-newsletter-label'),
        ),
        '#default_value' => $values->newsletter_opt_ins[$num]['label'],
      );

      $form['signature_newsletters'][$ord][$group_name]
        = bluestatedigital_forms_constituent_group($group_value);
      $form['signature_newsletters'][$ord][$group_name]['#title']
        = t('Analytics Newsletter Name');
      $form['signature_newsletters'][$ord][$group_name]['#description']
        = t('The title used by the analytics system to track user newsletter opt-ins. This value should correspond to the Blue State Digital constituent group configured on the @ord newsletter opt-in field of the signup form.', array('@ord' => $ord));
    }
  }
}

/**
 * Helper function for getting node configuration values.
 */
function signature_node_form_values($form, $form_state) {

  $node = $form['#node'];
  $settings = FALSE;

  $op_present = isset($form_state['values']['op']);
  $is_preview = $form_state['values']['op'] == t('Preview');
  if ($op_present && $is_preview) {
    // The node is being previewed, use the form values.
    $start_date = signature_date_to_timestamp(
      $form_state['values']['signature_start_date']
    );
    $end_date = signature_date_to_timestamp(
      $form_state['values']['signature_end_date']
    );
    $opt_ins = array();
    for ($num = 0; $num < 5; $num += 1) {
      $label_name = sprintf('signature_newsletter_label_%d', $num);
      $group_name = sprintf('signature_newsletter_group_%d', $num);
      $opt_ins[] = array(
        'label' => isset($form_state['values'][$label_name])
        ? $form_state['values'][$label_name] : '',
        'group' => isset($form_state['values'][$group_name])
        ? $form_state['values'][$group_name] : '',
      );
    }
    $values = array(
      'nid' => $node->nid,
      'type' => $form_state['values']['signature_type'],
      'goal' => $form_state['values']['signature_goal'],
      'bsd_form' => $form_state['values']['signature_bsd_form'],
      'limit_to_dates' => $form_state['values']['signature_limit_to_dates'],
      'start_date' => $start_date,
      'end_date' => $end_date,
      'sign_label' => $form_state['values']['signature_sign_label'],
      'newsletter_opt_ins' => $opt_ins,
      'restrictions' => $form_state['values']['signature_restrictions'],
      'terms_of_use' => $form_state['values']['signature_terms_of_use'],
      'display_disclaimer' => $form_state['values']['signature_display_disclaimer'],
    );
    $settings = entity_create('signature_node', $values);
  }
  elseif (isset($node->nid) && $node->nid > 0) {
    // Load the values from the database.
    $settings = entity_load_single('signature_node', $node->nid);
  }

  if (!$settings) {
    // New node or the node was created before the module was installed, use
    // default values.
    $values = array('nid' => $node->id);
    // TODO: Move the signature form heading to the content type, add sign
    // label default value field to the signature content types admin page.
    if ($node->type === 'petition_action') {
      $values['sign_label'] = 'Sign Now';
    }
    elseif ($node->type === 'pledge_action') {
      $values['sign_label'] = 'Sign Now';
    }
    elseif ($node->type === 'mos_action') {
      $values['sign_label'] = 'Send Your Support!';
    }
    else {
      $values['sign_label'] = 'Take Action';
    }
    $settings = entity_create('signature_node', $values);
  }

  return $settings;
}

/**
 * Helper function for converting UNIX timestamps to a date field value.
 */
function signature_timestamp_to_date($timestamp) {
  $date = getdate($timestamp);
  return array(
    'day' => $date['mday'],
    'month' => $date['mon'],
    'year' => $date['year'],
  );
}

/**
 * Helper function for converting a date field value to a UNIX timestamp.
 */
function signature_date_to_timestamp($date) {
  return mktime(0, 0, 0, $date['month'], $date['day'], $date['year']);
}

/**
 * Helper function for saving signature settings associated with a node.
 */
function signature_save_node_settings($node) {

  // Get any existing settings for the node.
  $settings = entity_load_single('signature_node', $node->nid);
  if ($settings === FALSE) {
    $settings = entity_create('signature_node', array('nid' => $node->nid));
  }

  $opt_ins = array();
  for ($num = 0; $num < 5; $num += 1) {
    $label_name = sprintf('signature_newsletter_label_%d', $num);
    $group_name = sprintf('signature_newsletter_group_%d', $num);
    $opt_ins[] = array(
      'label' => isset($node->{$label_name}) ? $node->{$label_name} : '',
      'group' => isset($node->{$group_name}) ? $node->{$group_name} : '',
    );
  }

  // Update the settins for the node.
  $settings->type = $node->signature_type;
  $settings->goal = $node->signature_goal;
  $settings->bsd_form = $node->signature_bsd_form;
  $settings->pm_signup_endpoint_id = 0;
  $settings->limit_to_dates = $node->signature_limit_to_dates;
  $settings->start_date = signature_date_to_timestamp($node->signature_start_date);
  $settings->end_date = signature_date_to_timestamp($node->signature_end_date);
  $settings->sign_label = $node->signature_sign_label;
  $settings->newsletter_opt_ins = $opt_ins;
  $settings->restrictions = $node->signature_restrictions;
  $settings->terms_of_use = $node->signature_terms_of_use;
  $settings->display_disclaimer = $node->signature_display_disclaimer;

  // Update the attached signup endpoint, or attach a new one if the node
  // is new.
  if (!empty($settings->bsd_form)) {
    $errors = array();
    $endpoint = signature_configure_signup_endpoint($settings->bsd_form,
      $settings->pm_signup_endpoint_id, $errors);
    if ($endpoint !== FALSE) {
      $endpoint->save();
      $settings->pm_signup_endpoint_id = $endpoint->getID();
    }

    // Display the errors to the user so they know things are not going to
    // go well for the action. Use the warning level severity as the action
    // is still saved.
    foreach ($errors as $error) {
      drupal_set_message($error, 'warning');
    }
  }
  elseif (!empty($settings->pm_signup_endpoint_id)) {
    SignatureSignupEndpoint::deleteByID($settings->pm_signup_endpoint_id);
  }

  // Save the settings for the node.
  entity_save('signature_node', $settings);
}

/**
 * Implements hook_node_insert().
 */
function signature_node_insert($node) {
  if (signature_node_is_signature_action($node)
  && $node->signature_settings_present) {
    $node->signatures = signature_save_node_settings($node);
  }
}

/**
 * Implements hook_node_update().
 */
function signature_node_update($node) {
  if (signature_node_is_signature_action($node)
  && $node->signature_settings_present) {
    $node->signatures = signature_save_node_settings($node);
  }
}

/**
 * Implements hook_node_delete().
 */
function signature_node_delete($node) {
  // Delete any existing node settings and field mapping.
  entity_delete('signature_node', $node->nid);
  variable_del("signature_mapping_node_{$node->nid}");
}

/**
 * Implements hook_entity_delete().
 */
function signature_entity_delete($entity, $type) {
  if ($type === 'signature_node') {
    // Delete the accompaning signup endpoint.
    if (!empty($entity->pm_signup_endpoint_id)) {
      SignatureSignupEndpoint::deleteByID($entity->pm_signup_endpoint_id);
    }
  }
}

function signature_build_plugin_configuration($form_id, &$errors) {

  static $groups = FALSE;

  try {

    // Get the fields on the signup form.
    $api = bluestatedigital_get_api('signup');
    $fields = $api->listFormFields($form_id);

    // Get a list of the constituent groups for error reporting.
    if ($groups === FALSE) {
      $api = bluestatedigital_get_api('group');
      $groups = $api->listConstituentGroups();
    }
  }
  catch (BlueStateDigitalApiException $ex) {
    $message = 'Error retrieving sign form description [@code] @body';
    watchdog('signature', $message, array(
      '@code' => $ex->getResponseCode(),
      '@body' => $ex->getResponseBody(),
    ));
    return FALSE;
  }

  // Invert the form field list to be keyed by label for quick lookup when
  // translating from the form field label to the signup field name.
  $by_label = array();
  foreach ($fields as $id => $field) {
    $by_label[$field['label']] = $id;
  }

  // Get the mapping configuration from the includesd config file.
  $label_to_name = signature_label_to_name_mapping();
  $label_to_opt_in = signature_label_to_opt_in_mapping();
  $group_configs = signature_constituent_group_configurations();

  // Map each form field to appropriate signup field using the form field's
  // label, collecting any errors to show to the user when the action is saved.
  $name_to_field_id = array();
  foreach ($label_to_name as $label => $name) {

    if (isset($by_label[$label])) {
      $name_to_field_id[$name] = $by_label[$label];
    }
    else {
      if ($name !== 'action.id' && $name !== 'action.message') {
        $errors[] = "[{$form_id}] {$label} not found on form.";
      }
    }
  }

  // The Blue Hornet configuration depends on the constituent group selected
  // in the Blue State Digital signup form admin. By default none of the opt-ins
  // are used.
  $bh_configuration = array(array(), array(), array(), array(), array());
  $opt_in_to_field_id = array(0,0,0,0,0);

  // Map the opt-ins.
  foreach ($label_to_opt_in as $label => $index) {

    if (isset($by_label[$label])) {
      $opt_in_to_field_id[$index] = $by_label[$label];

      // Pull the constituent group id from the field.
      $field = $fields[$by_label[$label]];
      $cons_group_id = $field['cons_group_id'];

      // Opt-ins are optional so not all of them will have group ids.
      if (!empty($cons_group_id)) {

        if (array_key_exists($cons_group_id, $group_configs)) {
          $bh_configuration[$index] = $group_configs[$cons_group_id];
        }
        else {
          if (isset($groups[$cons_group_id])) {
            $name = $groups[$cons_group_id]['name'];
            $errors[] = "[{$form_id}] Constituent group {$name} [{$cons_group_id}] on {$label} is not supported.";
          }
          else {
            $errors[] = "[{$form_id}] Unknown constituent group id {$cons_group_id} on {$label} is not supported.";
          }
        }
      }
    }
  }

  // Make sure only the email field is both shown and required.
  foreach ($fields as $field_id => $field) {
    if ($field['is_required'] && $field['is_shown'] && $field['label'] !== 'Email') {
      $errors[] = "[{$form_id}] {$field['label']} should not be required";
    }
  }

  return array(
    'bluestatedigital.pm_signup.handler' => array(
      'form-id' => $form_id,
      'field-ids' => $name_to_field_id,
      'opt-in-ids' => $opt_in_to_field_id,
    ),
    'bluehornet.pm_signup.handler' => array(
      'opt-ins' => $bh_configuration,
    ),
  );
}

/**
 * Helper function for saving the signature field mapping.
 */
function signature_configure_signup_endpoint($form_id, $endpoint_id, &$errors) {

  $configurations = signature_build_plugin_configuration($form_id, $errors);
  if ($configurations !== FALSE) {

    if (empty($endpoint_id)) {
      $endpoint = new SignatureSignupEndpoint();
    }
    else {
      $endpoint = SignatureSignupEndpoint::load($endpoint_id);
      if ($endpoint === FALSE) {
        $endpoint = new SignatureSignupEndpoint();
      }
    }

    foreach ($configurations as $name => $configuration) {
      $endpoint->setPluginEnabled($name, !empty($configuration));
      $endpoint->setPluginConfiguration($name, $configuration);
    }

    return $endpoint;
  }

  return FALSE;
}

/**
 * Implements hook_preprocess_field().
 */
function signature_preprocess_field(&$vars) {

  $field_name = $vars['element']['#field_name'];
  $view_mode = $vars['element']['#view_mode'];

  if ($field_name == 'field_action_type') {
    $object = $vars['element']['#object'];
    $type = $vars['element']['#entity_type'];
    $item = reset(field_get_items($type, $object, 'field_action_type'));
    if ($item !== FALSE && isset($item['taxonomy_term'])) {
      $action_type_class = 'action-type ' . $item['taxonomy_term']->name;
      $vars['classes_array'][] = drupal_html_class($action_type_class);
    }
  }
}

/**
 * Implements hook_preprocess_node().
 */
function signature_preprocess_node(&$vars) {
  $node = $vars['node'];
  $view_mode = $vars['view_mode'];
  $extra_classes = array(
    drupal_html_class('view-mode-' . $view_mode),
  );
  $vars['classes_array'] = array_merge($vars['classes_array'], $extra_classes);
}


/* Signature AJAX based state management.
 ******************************************************************************/
function signature_deliver_api_page($page_callback_result) {
  drupal_add_http_header('Content-Type', 'application/json');
  drupal_add_http_header('Status', $page_callback_result['status']);
  print drupal_json_encode($page_callback_result['payload']);
}

function signature_api_create($nid) {

  // Creates are done through a POST
  if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    return array(
      'status' => '405 Method Not Allowed',
      'payload' => array(
        'errors' => array(
          'HTTP method must be POST.'
        ),
      ),
    );
  }

  // Request content type must be JSON
  if ($_SERVER['CONTENT_TYPE'] !== 'application/json') {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Invalid request content type.',
        ),
      ),
    );
  }

  // First (and only) path element is a nid
  if (!preg_match('/^[0-9]+$/', $nid)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Invalid action id.',
        ),
      ),
    );
  }

  // The nid must point to a valid node
  $node = node_load($nid);
  if ($node === FALSE) {
    return array(
      'status' => '404 Not Found',
      'payload' => array(
        'errors' => array(
          'No such action exists.',
        ),
      ),
    );
  }

  // The action must support signatures
  if (!signature_node_is_signature_action($node)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'The requested action does not support signatures.',
        ),
      ),
    );
  }

  // The action must has a signature configuration
  $settings = entity_load_single('signature_node', $nid);
  if ($settings === FALSE || empty($settings->pm_signup_endpoint_id)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'The requested action is not configured for signatures.',
        ),
      ),
    );
  }

  // Decode the JSON payload
  $body = file_get_contents('php://input');
  $request = drupal_json_decode($body);
  if (!isset($request)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Unable to decode request payload.',
        ),
      ),
    );
  }

  // Validate the payload
  $validation_errors = array();
  if (!isset($request['first_name'])) {
    $validation_errors[] = 'First name is required.';
  }
  if (!isset($request['last_name'])) {
    $validation_errors[] = 'Last name is required.';
  }
  if (!isset($request['email'])) {
    $validation_errors[] = 'Email is required.';
  }
  if (!isset($request['display_signature'])) {
    $validation_errors[] = 'Signature display flag is required.';
  }
  if (!isset($request['opt_ins'])) {
    $validation_errors[] = 'Opt-in list is required.';
  }
  if (!is_array($request['opt_ins'])) {
    $validation_errors[] = 'Opt-in list must be an array.';
  }
  if (!empty($validation_errors)) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => $validation_errors,
      ),
    );
  }

  // Check that the email adress is in fact an email address
  if (!valid_email_address($request['email'])) {
    return array(
      'status' => '400 Bad Request',
      'payload' => array(
        'errors' => array(
          'Invalid email address.',
        ),
      ),
    );
  }

  // Translate the request body to the standard signup format
  $payload = array(
    'email' => $request['email'],
    'name.first' => $request['first_name'],
    'name.last' => $request['last_name'],
    'action.id' => $nid,
    'action.signature-type' => 'international_signature',
    'action.opt-ins.display' => $request['display_signature'],
  );

  // Newsletter opt-ins
  $opt_ins = array(
    'opt_in_1' => 'false',
    'opt_in_2' => 'false',
    'opt_in_3' => 'false',
    'opt_in_4' => 'false',
    'opt_in_5' => 'false',
  );
  foreach ($request['opt_ins'] as $opt_in) {
    $name = $opt_in['name'];
    if (!empty($opt_in['value']) && isset($opt_ins[$name])) {
      $opt_ins[$name] = 'true';
    }
  }
  $payload['action.opt-ins.newsletters'] = implode(',', $opt_ins);

  // Address
  if (!empty($request['address'])) {
    $payload['address.address'] = $request['address'];
  }
  if (!empty($request['city'])) {
    $payload['address.city'] = $request['city'];
  }
  if (!empty($request['postal_code'])) {
    $payload['address.postal-code'] = $request['postal_code'];
  }
  if (!empty($request['country'])) {
    $payload['address.country'] = $request['country'];
  }

  // Addresses in the US can have a state and ZIP code
  if (empty($request['country']) || $request['country'] == 'United States') {
    if (!empty($request['state'])) {
      $payload['address.state.code'] = $request['state'];
    }
    if (!empty($request['postal_code'])) {
      $payload['address.postal-code.type'] = 'ZIP';
    }
  }

  // Custom message (of support)
  if (!empty($request['message'])) {
    $payload['action.message'] = $request['address'];
    $payload['action.signature-type'] = 'mos_action';
  }

  // Partner code and opt-in
  if (!empty($_REQUEST['partner_code'])) {
    $payload['partner.code'] = $_REQUEST['partner_code'];
    if (!empty($request['partner_opt_in'])) {
      $payload['action.opt-ins.partner'] = '1';
    }
  }

  // Send the signup
  $sent = pm_signup_handle(array(
    'type' => 'signature',
    'endpoint' => $nid,
    'payload' => $payload,
  ));

  if ($sent === 'duplicate') {
    return array(
      'status' => '409 Conflict',
      'payload' => array(
        'errors' => array(
          'Signature already exists.',
        ),
      ),
    );
  }
  elseif ($sent === FALSE) {
    return array(
      'status' => '500 Internal Server Error',
      'payload' => array(
        'errors' => array(
          'Signup submission failed.',
        ),
      ),
    );
  }

  return array(
    'status' => '201 Created',
    'payload' => array(
      'id' => 0xDeadBeef,
    ),
  );
}
