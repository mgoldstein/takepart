<?php
/**
 * @file
 * The Wordlet Module
 */

/*
 * The configuration is stored in a separate file for easy edititing.
 */
include_once dirname(__FILE__) . '/wordlet.config.inc';

define('WORDLET_PLAIN_TEXT', 0);
define('WORDLET_SIMPLE_HTML', 1);
define('WORDLET_FULL_HTML', 2);

function wordlet_formats($value = NULL) {
  static $formats = array(
    0 => 'WORDLET_PLAIN_TEXT',
    1 => 'WORDLET_SIMPLE_HTML',
    2 => 'WORDLET_FULL_HTML'
  );
  if ( $value == NULL ) return $formats;
  if ( isset($formats[$value]) ) return $formats[$value];
  return NULL;
}

/**
 * Inverts the wordlet configuration array to be keyed by path.
 */
function wordlet_page_paths() {
  $values = &drupal_static(__FUNCTION__, array());
  if (!isset($values['paths'])) {
    $paths = array();
    foreach (_wordlet_configuration() as $name => $config) {
      if (!empty($config['path'])) {
        $paths[$config['path']] = $name;
      }
    }
    $values['paths'] = $paths;
  }
  return $values['paths'];
}

/**
 * Set or retrieve the active wordlet page configuration.
 */
function wordlet_active_page($page = NULL) {
  $value = &drupal_static(__FUNCTION__, FALSE);
  if (isset($page)) {
    $value = $page;
  }
  return $value;
}

/**
 * Fill out a wordlet page configuration with default values.
 */
function _wordlet_page_defaults(&$page, $name) {

  // All configurations should have a name and title
  $page += array(
    'name' => $name,
    'title' => $name,
    'published' => FALSE,
    'load' => array(),
  );

  if (!empty($page['path'])) {
    // Those configurations with a path should have content and wrapper
    // templates, a list of JS files, and a list of CSS files.
    $page += array(
      'wrappers' => array('html'),
      'css' => array(),
      'js' => array(),
    );
  }
  return $page;
}

/**
 * Wordlet page menu placeholder loader.
 */
function wordlet_page_load($name = NULL) {
  $values = &drupal_static(__FUNCTION__, array());

  if (isset($name)) {
    if (!isset($values[$name])) {
      // Requesting a single wordlet page
      $pages = _wordlet_configuration();
      if (isset($pages[$name])) {
        $values[$name] = _wordlet_page_defaults($pages[$name], $name);
      }
      else {
        $values[$name] = FALSE;
      }
    }
    return $values[$name];
  }
  else {
    // Requesting all wordlet pages
    foreach(_wordlet_configuration() as $name => $page) {
      if (!isset($values[$name])) {
        $values[$name] = _wordlet_page_defaults($page, $name);
      }
    }
    return $values;
  }
}

/**
 * Wordlet place holder loader.
 */
function wordlet_load($id = NULL) {
  $entities = entity_load('wordlet', isset($id) ? array($id) : FALSE);
  return isset($id) ? reset($entities) : $entities;
}

/**
 * Implements hook_entity_info().
 */
function wordlet_entity_info() {
  return array(
    'wordlet' => array(
      'label' => t('Wordlet'),
      'controller class' => 'WordletController',
      'base table' => 'wordlet',
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'fieldable' => FALSE,
      'exportable' => TRUE,
      'entity keys' => array(
        'id' => 'id',
        'status' => 'status',
        'module' => 'module',
      ),
      'entity class' => 'Wordlet',
      'access callback' => 'wordlet_access',
      'module' => 'wordlet',
      'admin ui' => array(
        'path' => 'admin/wordlet/page/%wordlet_page',
        'file' => 'wordlet.admin.inc',
        'controller class' => 'WordletUIController',
      ),
    )
  );
}

/**
 * Implements hook_permission().
 */
function wordlet_permission() {
  return array(
    'administer wordlet' => array(
      'title' => t('Administer wordlets'),
      'restrict access' => TRUE,
    ),
    'add wordlet' => array(
      'title' => t('Add wordlets'),
      'restrict access' => TRUE,
    ),
    'edit wordlet' => array(
      'title' => t('Edit wordlets'),
      'restrict access' => TRUE,
    ),
    'delete wordlet' => array(
      'title' => t('Delete wordlets'),
      'restrict access' => TRUE,
    ),
    'administer wordlet page' => array(
      'title' => t('Administer wordlet pages'),
      'restrict access' => TRUE,
    ),
    'view wordlet page' => array(
      'title' => t('View wordlet pages'),
    ),
    'preview wordlet page' => array(
      'title' => t('Preview unpublished wordlet pages'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Access callback for wordlet pages.
 */
function wordlet_page_access($op, $page = NULL) {
  // Block unknown operations.
  $allowed_ops = array('administer', 'view');
  if (in_array($op, $allowed_ops)) {
    // Adjust the operation for unpublished content
    $published = variable_get("wordlet_{$page['name']}_published",
      $page['published']);
    if ($op == 'view' && !$published) {
      $op = 'preview';
    }
    return user_access("$op wordlet page")
      || user_access("administer wordlet page");
  }
  return FALSE;
}

/**
 * Access callback for wordlets.
 */
function wordlet_access($op, $wordlet = NULL, $account = NULL,
  $entity_type = NULL) {
  // Block unknown operations.
  $allowed_ops = array('administer', 'add', 'edit', 'delete');
  if (in_array($op, $allowed_ops)) {
    return user_access("$op wordlet") || user_access("administer wordlet");
  }
  return FALSE;
}

/**
 * Implements hook_menu().
 */
function wordlet_menu() {
  return array(
    'admin/wordlet' => array(
      'title' => 'Wordlets',
      'description' => 'Manage wordlet pages.',
      'page callback' => 'wordlet_page_overview_callback',
      'access callback' => 'wordlet_page_access',
      'access arguments' => array('administer'),
      'weight' => 20,
      'type' => MENU_NORMAL_ITEM,
    ),
    'admin/wordlet/overview' => array(
      'title' => 'Overview',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -10,
    ),
    'admin/wordlet/export' => array(
      'title' => 'Export',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('wordlet_page_export_form'),
      'access callback' => 'wordlet_page_access',
      'access arguments' => array('administer'),
      'weight' => 0,
      'type' => MENU_LOCAL_TASK,
    ),
    'admin/wordlet/import' => array(
      'title' => 'Import',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('wordlet_page_import_form'),
      'access callback' => 'wordlet_page_access',
      'access arguments' => array('administer'),
      'weight' => 0,
      'type' => MENU_LOCAL_TASK,
    ),
    'wordlet/%wordlet_page' => array(
      'title callback' => 'wordlet_page_title',
      'title arguments' => array(1),
      'page callback' => 'wordlet_page_view_callback',
      'page arguments' => array(1),
      'access callback' => 'wordlet_page_access',
      'access arguments' => array('view', 1),
    ),
    'wordlet/%wordlet_page/view' => array(
      'title' => 'View',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -10,
    ),
    'wordlet/%wordlet_page/edit' => array(
      'title' => 'Edit',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('wordlet_page_edit_form', 1),
      'access callback' => 'wordlet_access',
      'access arguments' => array('edit'),
      'weight' => 0,
      'type' => MENU_LOCAL_TASK,
      'file' => 'wordlet.admin.inc',
      'file path' => drupal_get_path('module', 'wordlet'),
    ),
  );
}

/**
 * Implements hook_admin_paths().
 */
function wordlet_admin_paths() {
  return array(
    'wordlet/*/edit' => TRUE,
  );
}

/**
 * Implements hook_theme().
 */
function wordlet_theme() {
  $hooks = array();

  foreach (wordlet_page_load() as $name => $page) {

    if (!empty($page['path'])) {

      // content hook
      $theme_name = str_replace('_', '-', $wrapper);
      $hooks["wordlet_{$name}"] = array(
        'variables' => array(),
        'template' => "wordlet-{$theme_name}",
        'preprocess functions' => array(
          'wordlet_preprocess_page_template',
        ),
      );

      // wrapper hooks
      foreach ($page['wrappers'] as $wrapper) {
        $theme_wrapper = str_replace('_', '-', $wrapper);
        if (!isset($hooks["wordlet_wrapper_{$wrapper}"])) {
          $hooks["wordlet_wrapper_{$wrapper}"] = array(
            'render element' => 'unprocessed_content',
            'template' => "wordlet-wrapper-{$theme_wrapper}",
            'preprocess functions' => array(
              'wordlet_preprocess_wrapper_template',
            ),
            'override preprocess functions' => TRUE,
          );
        }
      }
    }
  }
  return $hooks;
}

/* I don't think this is actually used... tricky JP. */
function wordlet_preprocess_page_template(&$variables) {
  $variables['is_multipage'] = TRUE;
  _tp3_fill_template_vars($variables);
  $variables['header'] = theme('takepart3_header', $variables);
  $tabs = menu_local_tabs();
  if ($tabs) {
    $variables['header'] .= render($tabs);
  }
  $variables['footer'] = theme('takepart3_footer', $variables);
}

function wordlet_preprocess_wrapper_template(&$variables) {
  $variables['is_multipage'] = TRUE;
  _tp3_fill_template_vars($variables);
  $variables['header'] = theme('takepart3_header', $variables);
  $tabs = menu_local_tabs();
  if ($tabs) {
    $variables['header'] .= render($tabs);
  }
  $variables['footer'] = theme('takepart3_footer', $variables);
  $variables['content'] = $variables['unprocessed_content']['#children'];
  unset($variables['unprocessed_content']);
}

/**
 * Wordlet page title callback.
 */
function wordlet_page_title($page) {
  return $page['title'];
}

/**
 * Implements hook_url_inbound_alter().
 */
function wordlet_url_inbound_alter(&$path, $original_path, $path_language) {
  $paths = wordlet_page_paths();
  if (isset($paths[$original_path])) {
    $path = 'wordlet/' . $paths[$original_path];
  }
}

/**
 * Implements hook_url_outbound_alter().
 */
function wordlet_url_outbound_alter(&$path, &$options, $original_path) {
  $matches = array();
  if (preg_match('|^wordlet/([A-Za-z0-9_]+)(/view)?$|', $path, $matches)) {
    $wordlet_page = wordlet_page_load($matches[1]);
    if ($wordlet_page !== FALSE && !empty($wordlet_page['path'])) {
      $path = $wordlet_page['path'];
    }
  }
}

/**
 * Implements hook_preprocess_HOOK().
 */
function wordlet_preprocess_page(&$variables) {
  $config = wordlet_active_page();
  if ($config !== FALSE) {
    $variables['theme_hook_suggestions'][] = "wordlet_{$config['name']}";
    if ( isset($config['template']) )  $variables['theme_hook_suggestions'][] = "wordlet_{$config['template']}";
  }

  $page = wordlet_active_page();
  $preprocess_hook = "wordlet_page_{$page['name']}_preprocess";
  if (function_exists($preprocess_hook)) {
    call_user_func_array($preprocess_hook, array(&$variables));
  }
}

/**
 * Implements hook_page_alter().
 */
function wordlet_page_alter(&$page) {
  $config = wordlet_active_page();
  if ($config !== FALSE) {
    $page['#theme_wrappers'] = array();
    foreach ($config['wrappers'] as $wrapper) {
      if ($wrapper == 'html') {
        $page['#theme_wrappers'][] = $wrapper;
      }
      else {
        $page['#theme_wrappers'][] = "wordlet_wrapper_{$wrapper}";
      }
    }
  }
}

/**
 * Wordlet page admin overview callback.
 */
function wordlet_page_overview_callback() {

  // Table headers
  $active_header = array(
    t('Title'),
    t('Name'),
    t('Configured'),
    t('Pending'),
    array(
      'data' => t('Operations'),
      'colspan' => 2,
    ),
  );
  $orphan_header = array(
    t('Name'),
    t('Values'),
    t('Operations'),
  );

  // Destination for operation links
  $destination = drupal_get_destination();

  // Get the number of wordlets that have been configured
  $query = db_select('wordlet', 'w');
  $query->fields('w', array('page'));
  $query->addExpression('COUNT(w.name)', 'count');
  $query->condition('w.keys_data', '', '!=');
  $query->groupBy('w.page');
  $configured_counts = $query->execute()->fetchAllKeyed();

  // Get the number of wordlets that still need to be configured
  $query = db_select('wordlet', 'w');
  $query->fields('w', array('page'));
  $query->addExpression('COUNT(w.name)', 'count');
  $query->condition('w.keys_data', '', '=');
  $query->groupBy('w.page');
  $pending_counts = $query->execute()->fetchAllKeyed();

  // Load wordlet page configurations
  $active_pages = wordlet_page_load();

  $active_rows = array();
  foreach ($active_pages as $name => $page) {

    // Value count
    if (isset($configured_counts[$name])) {
      $configured_count = $configured_counts[$name]['count'];
    }
    else {
      $configured_count = 0;
    }
    if (isset($pending_counts[$name])) {
      $pending_count = $pending_counts[$name]['count'];
    }
    else {
      $pending_count = 0;
    }

    // Operations
    $list_operation = array(
      'data' => array(
        '#type' => 'link',
        '#title' => t('manage'),
        '#href' => 'admin/wordlet/page/' . $name,
      ),
    );
    if (!empty($page['path'])) {
      $view_operation = array(
        'data' => array(
          '#type' => 'link',
          '#title' => t('view'),
          '#href' => 'wordlet/' . $name,
        ),
      );
    }
    else {
      $view_operation = '';
    }

    $active_rows[$name] = array(
      $page['title'],
      $name,
      $configured_count,
      $pending_count,
      $view_operation,
      $list_operation,
    );
  }

  // Get the number of wordlets that are not listed in the configuration
  $query = db_select('wordlet', 'w');
  $query->fields('w', array('page'));
  $query->addExpression('COUNT(w.name)', 'count');
  $query->condition('w.page', array_keys($active_pages), 'NOT IN');
  $query->groupBy('w.page');
  $orphan_pages = $query->execute()->fetchAllKeyed();

  ksort($orphan_pages);

  $orphan_rows = array();
  foreach ($orphan_pages as $name => $count) {

    // Operations
    $list_operation = array(
      'data' => array(
        '#type' => 'link',
        '#title' => t('manage'),
        '#href' => 'admin/wordlet/page/' . $name,
      ),
    );

    $orphan_rows[$name] = array(
      $name,
      $count,
      $list_operation,
    );
  }

  // Return the page content
  return array(
    'active_heading' => array(
      '#theme' => 'html_tag',
      '#tag' => 'h2',
      '#value' => t('Active Wordlet Pages'),
    ),
    'wordlet_pages' => array(
      '#theme' => 'table',
      '#header' => $active_header,
      '#rows' => $active_rows,
      '#empty' => t('No worldet pages available.'),
    ),
    'orphan_heading' => array(
      '#theme' => 'html_tag',
      '#tag' => 'h2',
      '#value' => t('Orphan Wordlet Pages'),
    ),
    'orphan_pages' => array(
      '#theme' => 'table',
      '#header' => $orphan_header,
      '#rows' => $orphan_rows,
      '#empty' => t('None (someone took Jonathan Swift seriously)'),
    ),
  );
}

/**
 * Wordlet page admin export form.
 */
function wordlet_page_export_form($form, &$form_state) {

  $json = array();

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'wordlet');
  $result = $query->execute();

  if (!empty($result['wordlet'])) {
    $entities = entity_load('wordlet', array_keys($result['wordlet']));
    foreach ($entities as $entity) {
      $wrapper = entity_metadata_wrapper('wordlet', $entity);
      $data = array();
      foreach ($wrapper->getIterator() as $name => $property) {
        $data[$name] = $property->value();
      }
      $json[] = $data;
    }
  }

  $form['json'] = array(
    '#title' => t('Exported wordlets'),
    '#description' => t('Exported wordlets as a JSON array suitable for using
      when importing wordlets'),
    '#type' => 'textarea',
    '#rows' => 20,
    '#cols' => 80,
    '#default_value' => drupal_json_encode($json),
  );

  return $form;
}

/**
 * Wordlet page admin import form.
 */
function wordlet_page_import_form($form, &$form_state) {

  $form['json'] = array(
    '#title' => t('Wordlets to import'),
    '#description' => t('JSON array of wordlets to import.'),
    '#type' => 'textarea',
    '#rows' => 20,
    '#cols' => 80,
    '#default_value' => '',
  );

  $form['overwrite'] = array(
    '#title' => t('Check this box to overwrite any existing wordlets in
      the database that are also present in the JSON import data. Otherwise, the
      import will be aborted (<em>NO wordlets will be imported</em>) if one or
      more wordlets in the JSON import data already exists in the database.'),
    '#description' => t('Overwrite existing wordlets.'),
    '#type' => 'checkbox',
    '#default_value' => NULL,
  );

  $form['actions'] = array('#type' => 'actions');
  $submit = array();
  if (!empty($form['#submit'])) {
    $submit += $form['#submit'];
  }
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Import wordlets'),
    '#weight' => 40,
  );

  return $form;
}

/**
 * Wordlet page admin import form.
 */
function wordlet_page_import_form_validate($form, &$form_state) {

  $json = drupal_json_decode($form_state['values']['json']);
  if (!isset($json)) {
    form_set_error('json', t('The import data could not be parsed.'));
  }
  elseif (empty($json)) {
    form_set_error('json', t('There is nothing to import.'));
  }
  else {
    $incomplete = 0;
    $existing = 0;
    foreach ($json as $wordlet) {

      // Check each wordlet for the required keys
      if (isset($wordlet['name']) && isset($wordlet['page'])) {

        // Check for collisions if overwrite was not selected
        if (empty($form_state['values']['overwrite'])) {
          $result = db_select('wordlet', 'w')
            ->fields('w')
            ->condition('w.page', $wordlet['page'])
            ->condition('w.name', $wordlet['name'])
            ->execute();
          if ($result->rowCount()) {
            $existing += 1;
            drupal_set_message(t('Wordlet @name already exists for @page.', array(
              '@name' => $wordlet['name'], '@page' => $wordlet['page'])), 'warning');
          }
        }
      }
      else {
        $incomplete += 1;
      }
    }

    if ($existing > 0) {
      form_set_error('json', t('@count wordlets already exist.', array(
        '@count' => $existing)));
    }
    if ($incomplete > 0) {
      form_set_error('json', t('@count wordlets are missing key values.', array(
        '@count' => $incomplete)));
    }
  }
}

/**
 * Wordlet page admin import form.
 */
function wordlet_page_import_form_submit($form, &$form_state) {

  $json = drupal_json_decode($form_state['values']['json']);

  $imported = 0;
  if (!empty($json)) {
    foreach ($json as $wordlet) {

      // Default values.
      $values = array(
        'page' => '',
        'name' => '',
        'title' => '',
        'description' => '',
        'format' => WORDLET_PLAIN_TEXT,
        'enabled' => 1,
        'cardinality' => 1,
        'weight' => 0,
        'items_data' => '',
        'keys_data' => '',
      );

      // Check for any existing wordlet, or create a new one
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'wordlet');
      $query->propertyCondition('page', $wordlet['page']);
      $query->propertyCondition('name', $wordlet['name']);
      $result = $query->execute();

      if (!empty($result['wordlet'])) {
        $entities = entity_load('wordlet', array_keys($result['wordlet']));
        $entity = reset($entities);
      }
      else {
        $entity = entity_create('wordlet', $values);
      }

      // Set the wordlet properties
      foreach (array_keys($values) as $attribute) {
        if (isset($wordlet[$attribute])) {
          $entity->{$attribute} = $wordlet[$attribute];
        }
      }

      $items = unserialize($entity->items_data);
      if (!empty($items) && is_array($items)) {
        $entity->items = $items;
      }
      $entity->item_keys = explode(',', $entity->keys_data);

      // Save.
      $entity->save();
      $imported += 1;
    }
  }

  drupal_set_message(t('@count wordlet(s) imported.', array(
    '@count' => $imported)));
}

/**
 * Wordlet page full page edit form
 */
function wordlet_page_edit_form($form, &$form_state, $page) {

  // No such page.
  if ($page === FALSE) {
    return drupal_not_found();
  }

  $form_state['wordlet_page'] = $page;

  $form['published'] = array(
    '#title' => t('Published'),
    '#description' => t('Override the published state for the page.'),
    '#type' => 'checkbox',
    '#default_value' => variable_get("wordlet_{$page['name']}_published", $page['published']),
  );

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'wordlet');
  $query->propertyCondition('page', $page['name']);
  $query->propertyCondition('keys_data', '', '!=');
  $query->propertyOrderBy('weight');
  $result = $query->execute();

  if (!empty($result['wordlet'])) {

    $form['fields'] = array(
      '#type' => 'container',
      '#tree' => TRUE,
    );

    $entities = entity_load('wordlet', array_keys($result['wordlet']));

    foreach ($entities as $entity) {
      $form['fields'][$entity->name] = array(
        '#type' => 'container',
        '#tree' => TRUE,
      );
      $form['fields'][$entity->name] += wordlet_get_item_fields($entity);
    }

    $form['actions'] = array('#type' => 'actions');
    $submit = array();
    if (!empty($form['#submit'])) {
      $submit += $form['#submit'];
    }
    $form['actions']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Save wordlet'),
      '#weight' => 40,
    );

    // Save the wordlets for the submit handler.
    $form_state['wordlets'] = $entities;
  }

  return $form;
}

function wordlet_page_edit_form_submit($form, &$form_state) {

  $page = $form_state['wordlet_page'];


  if (empty($form_state['values']['published']) == empty($page['published'])) {
    variable_del("wordlet_{$page['name']}_published");
  }
  else {
    variable_set("wordlet_{$page['name']}_published", $form_state['values']['published']);
  }

  $wordlets = $form_state['wordlets'];
  foreach ($wordlets as $wordlet) {
    if (isset($form_state['values']['fields'][$wordlet->name])) {
      $values = $form_state['values']['fields'][$wordlet->name];
      wordlet_update_items_from_fields($wordlet, $values);
      $wordlet->save();
    }
  }

  drupal_set_message(t('The page @title has been updated.',
    array('@title' => $page['title'])));
}

function wordlet_load_for_page($page) {

  $wordlets = array();

  // Limit that query to wordlets for the page.
  $load = array_merge($page['load'], array($page['name']));
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'wordlet');
  $query->propertyCondition('page', $load, 'IN');

  $result = $query->execute();
  if (!empty($result['wordlet'])) {
    $entities = entity_load('wordlet', array_keys($result['wordlet']));
    foreach ($entities as $entity) {
      if (isset($wordlets[$entity->name])) {
        $existing = $wordlets[$entity->name];
        if (empty($existing->keys_data) == empty($entity->keys_data)) {
          // They are both configured, or both not configured, the position
          // in the load array determines which to use
          $existing_pos = array_search($existing->page, $load);
          $current_pos = array_search($entity->page, $load);
          if ($existing_pos < $current_pos) {
            $wordlets[$entity->name] = $entity;
          }
        }
        elseif (!empty($entity->keys_data)) {
          // The current entity should be used regardless of position in the
          // load array as it is the one that is configured
          $wordlets[$entity->name] = $entity;
        }
      }
      else {
        // First time encountering this name
        $wordlets[$entity->name] = $entity;
      }
    }
  }

  return $wordlets;
}

/**
 * Wordlet page view callback.
 */
function wordlet_page_view_callback($page) {
  if ( function_exists("wysiwyg_get_profile") ) {
    wysiwyg_get_profile('full_html');
  }

  // No such page.
  if ($page === FALSE) {
    return drupal_not_found();
  }

  // Load the wordlets that will be used on the page
  $page['wordlets'] = wordlet_load_for_page($page);

  // Set the active page configuration
  wordlet_active_page($page);

  $alter_hook = "wordlet_{$page['name']}_page_alter";
  if (function_exists($alter_hook)) {
    call_user_func_array($alter_hook, array($page));
  }

  $title = '';
  if (isset($page['wordlets']['title'])) {
    $tw = $page['wordlets']['title'];
    if (count($tw->items)) {
      $title = $tw->items[0]['single'];
    }
  }
  $title = variable_get("wordlet_{$page['name']}_title", $title);
  if (!empty($title)) {
    drupal_set_title($title);
  }

  // Facebook image og tag
  $fb_image = '';
  if (isset($page['wordlets']['fb_image'])) {
    $tw = $page['wordlets']['fb_image'];
    if (count($tw->items)) {
      $fb_image = $tw->items[0]['single'];
    }
  }
  $fb_image = variable_get("wordlet_{$page['name']}_fb_image", $fb_image);
  if (!empty($fb_image)) {
    $metatag = array(
      '#type' => 'html_tag',
      '#tag' => 'meta',
      '#attributes' => array(
        'property' => 'og:image',
        'content' =>  $fb_image,
      ),
     );

    drupal_add_html_head( $metatag, 'facebook_image');
  }

  // $og_title = array(
  //   '#type' => 'html_tag',
  //   '#tag' => 'meta',
  //   '#attributes' => array(
  //     'property' => 'og:title',
  //     'content' =>  $title,
  //   ),
  //  );
  // drupal_add_html_head( $og_title, 'og_title');

  global $base_url;
  $url = $base_url. '/'. current_path();
  /*
  $og_url = array(
    '#type' => 'html_tag',
    '#tag' => 'meta',
    '#attributes' => array(
      'property' => 'og:url',
      'content' =>  $url,
    ),
   ); */
  drupal_add_html_head( $og_url, 'og_url');

  // $og_type = array(
  //   '#type' => 'html_tag',
  //   '#tag' => 'meta',
  //   '#attributes' => array(
  //     'property' => 'og:type',
  //     'content' =>  'article',
  //   ),
  //  );
  // drupal_add_html_head($og_type, 'og_type');





  // Google add slots
  if (isset($page['wordlets']['google_ad_slots'])) {
    $tw = $page['wordlets']['google_ad_slots'];
    foreach ($tw->items as $item) {

      // Ad slot is stored in single
      $slot = $item['single'];

      // GPT id is stored in token
      $gptid = $item['token'];

      $property_code = variable_get('takepart_ads_dfp_property_code', '');
      if(!empty($slot) && $property_code) {
        if(!empty($gptid)) {
          $gptid = array($slot => $gptid);
          takepart_gpt_ads($gptid);
        }
        takepart_ads($slot);
      }
    }
  }

  // Facebook description og tag
  $fb_description = '';
  if (isset($page['wordlets']['fb_description'])) {
    $tw = $page['wordlets']['fb_description'];
    if (count($tw->items)) {
      $fb_description = $tw->items[0]['single'];
    }
  }

  $fb_description = variable_get("wordlet_{$page['name']}_fb_description", $fb_description);
  if (!empty($fb_description)) {
    $metatag = array(
      '#type' => 'html_tag',
      '#tag' => 'meta',
      '#attributes' => array(
        'property' => 'og:description',
        'content' =>  $fb_description,
      ),
    );

    drupal_add_html_head( $metatag, 'facebook_description');
  }

  // meta desciption
  $meta_description = '';
  if (isset($page['wordlets']['meta_description'])) {
    $tw = $page['wordlets']['meta_description'];
    if (count($tw->items)) {
      $meta_description = $tw->items[0]['single'];
    }
  }

  $meta_description = variable_get("wordlet_{$page['name']}_meta_description", $meta_description);
  if (!empty($meta_description)) {
    $metatag = array(
      '#type' => 'html_tag',
      '#tag' => 'meta',
      '#attributes' => array(
        'name' => 'description',
        'content' =>  $meta_description,
      ),
    );

    drupal_add_html_head( $metatag, 'meta_description');
  }

  // Add the page CSS and JS.
  foreach ($page['css'] as $filename) {
    drupal_add_css(WORDLET_CSS_DIRECTORY . $filename, array(
      'type' => 'file',
      'group' => CSS_THEME,
      'weight' => 20,
    ));
  }
  foreach ($page['js'] as $filename) {
    drupal_add_js(WORDLET_JS_DIRECTORY . $filename, array(
      'type' => 'file',
      'group' => JS_THEME,
      'weight' => 20,
    ));
  }

  if (wordlet_access('edit')) {
    $path = drupal_get_path('module', 'wordlet');
    drupal_add_css($path . '/css/wordlet.css', array(
      'type' => 'file',
      'group' => CSS_THEME,
      'weight' => 20,
    ));
    drupal_add_js($path . '/js/wordlet.js', array(
      'type' => 'file',
      'group' => JS_THEME,
      'weight' => 20,
    ));
  }

  $alterfn = 'wordlet_' . $page['name'] . '_page_alter';
  if ( function_exists($alterfn) ) {
    call_user_func_array($alterfn, array($page));
  }

  // Structure is in the template, content in the wordlets.
  return '';
}

function wordlet_omniture_variables() {
  $return = array();

  $campaign_name = wordlet('campaign_name');

  if ( !empty($campaign_name) ) {
    $single = trim($campaign_name->single(false));
    if ( $single == 'Social Interstitial: Popup View' ) {
      $return = array(
        's.prop46' => $single
      );
    } else {
      $return = array(
        's.channel' => $single,
        's.eVar43' => $single,
        's.prop43' => $single
      );
    }
  }

  return array("variables" => $return);
}

/* =========================================================
  Template helpers
========================================================= */

function wordlet_edit_mode($configure = FALSE) {
  if (!empty($_COOKIE['show_wordlets'])) {
    if ($configure) {
      return wordlet_access('administer');
    }
    else {
      return wordlet_access('edit');
    }
  }
  return FALSE;
}

function wordlet($name) {
  $page = wordlet_active_page();
  if ($page === FALSE) {
    return NULL;
  }
  if (isset($page['wordlets'][$name])) {
    $wordlet = $page['wordlets'][$name];
  }
  else {
    $values = array(
      'page' => $page['name'],
      'name' => $name,
      'cardinality' => 1,
    );
    $wordlet = entity_create('wordlet', $values);
    $wordlet->save();
    $page['wordlets'][$name] = $wordlet;
    wordlet_active_page($page);
  }

  $controller = entity_get_controller('wordlet');
  $w = $controller->viewOne($wordlet);

  return $w;
}

function w() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

function wordlet_list($name, $randomize = false) {
  $page = wordlet_active_page();
  if ($page === FALSE) {
    return NULL;
  }
  if (isset($page['wordlets'][$name])) {
    $wordlet = $page['wordlets'][$name];
  }
  else {
    $values = array(
      'page' => $page['name'],
      'name' => $name,
      'cardinality' => 1,
    );
    $wordlet = entity_create('wordlet', $values);
    $wordlet->save();
    $page['wordlets'][$name] = $wordlet;
    wordlet_active_page($page);
  }

  $controller = entity_get_controller('wordlet');
  $wl = $controller->viewList($wordlet, $randomize);
  if ($wl->count() == 0) { echo wordlet($name); }

  return $wl;
}

function wl() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_list', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

/* Sort of useless because Drupal caching, so just commenting for now
function wordlet_random($name) {
  $wl = wordlet_list($name);
  if ( get_class($wl) != 'WordletList' ) return $wl;
  $rnd = rand(0, $wl->count() - 1);
  foreach ( $wl as $i => $w ) {
    if ( $i == $rnd ) return $w;
  }
}

function wr() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_random', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}*/

function wordlet_generator($name) {
  $values = &drupal_static(__FUNCTION__, array());
  if (!isset($values[$name])) {
    $values[$name] = wordlet_list($name);
  }
  if ($values[$name]->valid()) {
    $value = $values[$name]->current();
    $values[$name]->next();
    return $value;
  }
  return NULL;
}

function wg() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_generator', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

// Return URL for requested wordlet page
function wordlet_url($name) {
  global $base_url;

  $config = _wordlet_configuration();
  if (isset($config[$name]) && isset($config[$name]['path']) ) {
    return $base_url . '/' . $config[$name]['path'];
  }
  return '';
}

function wu() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_url', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

function wordlet_configure_links() {
  if ( !wordlet_access('administer') ) return false;
  $links = array();
  $config = wordlet_active_page();
  if ( isset($config['load']) && is_array($config['load']) ) {
    foreach ( $config['load'] as $name ) {
      $links[] = '<a href="/admin/wordlet/page/' . $name . '">' . $name . '</a>';
    }
  }

  $links[] = '<a href="/admin/wordlet/page/' . $config['name'] . '">' . $config['name'] . '</a>';

  return $links;
}

// Make a html friendly class name of any string
function wordlet_classify($string) {
  $string = preg_replace('/[^a-zA-Z0-9_]+/', '-', $string);
  $string = trim($string, '-');
  if ( !preg_match('/^[\-a-z_]/', $string) ) {
    $string = '-' . $string;
  }
  return $string;
}

function wc() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_classify', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

// Return wordlet markup
function wordlet_edit($name) {
  if ( !wordlet_edit_mode() ) return '';
  $w = wordlet($name);

  $markup = $w . '';

  if ( $w->title ) {
    $word = $w->__toString(false);
    $markup = str_replace($word, 'Edit ' . $w->title, $markup);
  }

  return $markup;
}

function we() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_edit', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

// Return wordlet edit URL in a data-wordlet-edit attribute
function wordlet_edit_attribute($name) {
  if ( !wordlet_edit_mode() ) return '';
  $w = wordlet($name);
  $data_configure = '';
  if ( wordlet_access('administer') ) $data_configure = ' data-configure="/admin/wordlet/page/' . $w->page . '/manage/' . $w->id . '/configure"';
  $data_edit = '';
  if ( $w->configured ) $data_edit = ' data-edit="/admin/wordlet/page/' . $w->page . '/manage/' . $w->id . '/edit"';
  return $data_configure . $data_edit;
}

function wa() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_edit_attribute', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

// Find wordlet in wordlet list based on "key"
function wordlet_find($name, $key, $value) {
  foreach( wordlet_list($name) as $w ) {
    if ( $w->{$key} == $value ) return $w;
  }

  return null;
}

function wf() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_find', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

// Is the current page the same as the entered URL
function wordlet_active_page_or_section($href, $return_value_if_true = 'active') {
  $current_path = trim($_SERVER['REQUEST_URI'], '/');
  $href = trim($href, '/');
  $parts = explode('/', $href);
  $match = false;

  if ( count($parts) == 1 && $href == $current_path ) {
    $match = true;
  } elseif ( count($parts) > 1 && strpos($current_path, $href) === 0 ) {
    $match = true;
  }

  if ( $match ) return $return_value_if_true;
  return NULL;
}

function ws() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_active_page_or_section', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

// Replace tokens in wordlets
function wordlet_token_replace($string, $replace) {
  /*if ( get_class($replace) == 'WordletItem' ) {
    $array = (Array)$replace;
    $array = $array['args'];
  } else {
    $array = (Array)$replace;
  }*/

  $array = $replace;

  $ret = $string;
  if ( (preg_match_all('/\{([a-zA-Z\-_]+)\}/', $string, $matches)) && isset($matches[1]) ) {
    foreach ( $matches[1] as $key => $match ) {
      if ( gettype($array) == 'object' ) {
        if ( $match == 'single' || $match == 'multi' ) {
          $find = $array->{$match}(false);
        } else {
          $find = $array->{$match};
        }
      } else {
        // untested
        $find = $array[$match];
      }

      if ( !empty($find) ) {
        $ret = str_replace($matches[0][$key], $find, $ret);
      } else {
        $ret = str_replace($matches[0][$key], '', $ret);
      }
    }
  }

  return $ret;
}

function wr() {
  try {
    $func_get_args = func_get_args();
    return call_user_func_array('wordlet_token_replace', $func_get_args);
  } catch (Exception $e) {
    return '';
  }
}

