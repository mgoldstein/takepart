<?php

/**
 * Implements hook_menu().
 */
function cleanup_pathauto_menu() {
  $items['admin/config/search/path_alias_cleanup'] = array(
    'title' => 'Path Alias Cleanup',
    'description' => 'List path aliases with improper characters.',
    'page callback' => 'cleanup_pathauto_list',
    'access callback' => 'user_access',
    'access arguments' => array('administer pathauto'),
  );
  $items['admin/config/search/path_alias_cleanup/list'] = array(
    'title' => 'List Improper Aliases',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'page callback' => 'cleanup_pathauto_list',
    'access callback' => 'user_access',
    'access arguments' => array('administer pathauto'),
  );
  $items['admin/config/search/path_alias_cleanup/repair'] = array(
    'title' => 'Repair Improper Path Aliases',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'cleanup_pathauto_repair',
    'access callback' => 'user_access',
    'access arguments' => array('administer pathauto'),
  );
  $items['admin/config/search/path_alias_cleanup/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cleanup_pathauto_settings_form'),
    'access arguments' => array('administer pathauto'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 20,
    'file' => 'cleanup_pathauto.admin.inc',
  );

  return $items;
}


/***
 * Report improper path aliases
 *
 * @param $repair     // true = also make repairs
 */
function cleanup_pathauto_list($repair = false) {
  // the next two arrays contain info from the url_alias table;
  // source is pid**node
  // contains list of all aliases; source => alias
  $aliases = array();

  // contains list of nodes with improper characters, source => string
  $improper = array();

  // count of repaired nodes
  $repaired_nodes = 0;


  // allowed characters (regex)
  $cleanup_pathauto_allowed_chars = variable_get('cleanup_pathauto_allowed_chars', '');

  // prepare for table-style output
  $header = array('Source', 'Alias');
  $rows = array();

  // fetch list of aliases
  $alias_count = _cleanup_pathauto_get_improper_aliases($aliases, $improper);

  foreach ($improper as $source => $alias) {
    // extract pid and node from source
    list($pid, $node) = preg_split('/\*\*/', $source);

    // corrected strings are built as errors are detected
    $corrected = "";

    // uncomment next line to show original line
    //$output .= $alias . '<br />';

    // display aliases, highlighting improper characters
    $in_bogus = false;      // true if in a bogus char span - this allows us to not have to put a span around individual chars
    $needs_repair = false;  // true if alias needs repairing
    $line = "";             // line buffer
    for ($i=0; $i < strlen($alias); $i++) {
      $char = $alias[$i];
      $bogus = preg_match($cleanup_pathauto_allowed_chars, $char);
      if ($bogus) {
        // an improper char
        $corrected .= '-';
        if (!$in_bogus) {
          $line .= '<span class="bogus">';
          $in_bogus = true;
          $needs_repair = true;
        }
        $iv = intval($char);
        if (ord($char) == 0) {
          // zeroes don't show up on display - replace with ?
          $char = '?';
        }
      }
      else {
        // not an improper char
        $corrected .= $char;
        if ($in_bogus) {
          $line .= '</span>';
          $in_bogus = false;
        }
      }
      $line .= $char;
    }

    // end of line - check flag in case last char was bogus
    if ($in_bogus) {
      $line .= '</span>';
    }

    if (($repair) && ($needs_repair)) {
      // repair the alias
      $corrected = $corrected;
      // see http://api.drupal.org/api/drupal/includes%21database%21database.inc/function/db_update/7
      $status = db_update('url_alias')
                  ->fields(array(
                    'alias' => $corrected
                ))
                ->condition('pid', $pid, '=')
                ->execute();

      $repaired_nodes++;
    }

    $rows[] = array(array('data' => $node, 'class' => 'source'), array('data' => $line, 'class' => 'alias'));
    $line = "";
  }


  $output = '<p>' . $alias_count . ' nodes found</p>';
  if ($repair) {
    $output = '<p>' . format_plural($repaired_nodes, '1 node', '@count nodes') . ' repaired</p>';
    drupal_set_title('Repair Improper Path Aliases');
  }
  $output .= '<p class="final">' . count($improper) . ' improper strings found</p>';

  $output .= theme('table', array('header' => $header, 'rows' => $rows ));

  $module_path = drupal_get_path('module', 'cleanup_pathauto');
  drupal_add_css($module_path . '/cleanup_pathauto.css');
  $output = '<div class="cleanup-pathauto">' . $output . '</div>';

  return $output;
}


/**
 * @function: create lists of aliases and improper aliases found (internal only)
 *
 * @param $aliases    // reference to where to store list of all aliases
 * @param $improper   // reference to where to store list of improper aliases
 * @return count of aliases found
 */
function _cleanup_pathauto_get_improper_aliases(&$aliases, &$improper) {
  // types of nodes to check
  $cleanup_pathauto_check_nodes = preg_split("/\r\n/", variable_get('cleanup_pathauto_check_nodes', 'article'));

  // allowed characters (regex)
  $cleanup_pathauto_allowed_chars = variable_get('cleanup_pathauto_allowed_chars', '');

  $sql = <<<EOT
SELECT pid, source, alias FROM {url_alias} ua
ORDER BY ua.source
EOT;

  $result = db_query($sql);
  foreach ($result as $record) {
    $status = preg_match("/([^\/]+)\/(.+)/", $record->alias, $res);
    if ($status) {
      $path = $res[1];
      $arg = $res[2];

      if (in_array($path, $cleanup_pathauto_check_nodes)) {
        $index = $record->pid . '**' . $record->source;
        $aliases[$index] = $record->alias;
        if (preg_match($cleanup_pathauto_allowed_chars, $arg)) {
          $improper[$index] = $arg;
        }
      }
    }
  }

  return count($aliases);
}


/**
 * Implements hook_entity_presave($entity, $type)().
 *
 * This checks the path for non-standard characters and replaces them with hyphens
 */
function cleanup_pathauto_entity_presave($entity, $type) {
  if ($type == 'node') {
    // allowed characters (regex)
    $cleanup_pathauto_allowed_chars = variable_get('cleanup_pathauto_allowed_chars', '');

    $alias = $entity->path['alias'];
    $improper_chars = 0;    // # of improper chars found
    $corrected = '';

    // walk alias string, looking for improper characters
    for ($i=0; $i < strlen($alias); $i++) {
      $char = $alias[$i];
      $bogus = preg_match($cleanup_pathauto_allowed_chars, $char);
      if ($bogus) {
        // an improper char
        $corrected .= '-';
        $improper_chars++;
      }
      else {
        // not an improper char
        $corrected .= $char;
      }
    }

    if ($improper_chars > 0) {
      $entity->path['alias'] = $corrected;
      watchdog('cleanup_pathauto', ':improper_chars characters replaced while creating node alias %alias', array(':improper_chars' => $improper_chars, '%alias' => $corrected), WATCHDOG_NOTICE);
    }
  }
}


/***
 * repair improper aliases
 */
function cleanup_pathauto_repair() {
  return cleanup_pathauto_list(true);
}


