<?php

/**
 * Implements hook_menu().
 */
function cleanup_pathauto_menu() {
  $items['admin/config/search/path_alias_cleanup'] = array(
    'title' => 'Path Alias Cleanup',
    'description' => 'List path aliases with improper characters.',
    'page callback' => 'cleanup_pathauto_list',
    'access callback' => 'user_access',
    'access arguments' => array('administer pathauto'),
  );
  $items['admin/config/search/path_alias_cleanup/list'] = array(
    'title' => 'List Improper Aliases',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'page callback' => 'cleanup_pathauto_list',
    'access callback' => 'user_access',
    'access arguments' => array('administer pathauto'),
  );
  $items['admin/config/search/path_alias_cleanup/repair'] = array(
    'title' => 'Repair Improper Path Aliases',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'cleanup_pathauto_repair',
    'access callback' => 'user_access',
    'access arguments' => array('administer pathauto'),
  );
  $items['admin/config/search/path_alias_cleanup/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cleanup_pathauto_settings_form'),
    'access arguments' => array('administer pathauto'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 20,
    'file' => 'cleanup_pathauto.admin.inc',
  );

  return $items;
}


/***
 * Report improper path aliases
 *
 * @param $repair     // true = also make repairs
 */
function cleanup_pathauto_list($repair = false) {
  // the next two arrays contain info from the url_alias table;
  // source is pid**node
  // contains list of all aliases; source => alias
  $aliases = array();

  // contains list of nodes with improper characters, source => string
  $improper = array();

  // count of repaired nodes
  $repaired_nodes = 0;


  // allowed characters (regex)
  $cleanup_pathauto_allowed_chars = variable_get('cleanup_pathauto_allowed_chars', '');

  // prepare for table-style output
  $header = array('Source', 'Alias');
  $rows = array();

  // fetch list of aliases
  $alias_count = _cleanup_pathauto_get_improper_aliases($aliases, $improper);

  foreach ($improper as $source => $alias) {
    // extract pid and node from source
    list($pid, $node) = preg_split('/\*\*/', $source);

    // corrected strings are built as errors are detected
    $corrected = "";

    // uncomment next line to show original line
    //$output .= $alias . '<br />';

    // display aliases, highlighting improper characters
    $in_bogus = false;      // true if in a bogus char span - this allows us to not have to put a span around individual chars
    $needs_repair = false;  // true if alias needs repairing
    $line = "";             // line buffer
    for ($i=0; $i < strlen($alias); $i++) {
      $char = $alias[$i];
      $bogus = preg_match($cleanup_pathauto_allowed_chars, $char);
      if ($bogus) {
        // an improper char
        if (cleanup_pathauto_is_dash($char)) {
          // replace em or endash with hyphen
          $corrected .= '-';
        }
        else {
          // ignore all other improper chars
          $corrected .= '';
        }

        if (!$in_bogus) {
          $line .= '<span class="bogus">';
          $in_bogus = true;
          $needs_repair = true;
        }
        $iv = intval($char);
        if (ord($char) == 0) {
          // zeroes don't show up on display - replace with ?
          $char = '?';
        }
      }
      else {
        // not an improper char
        $corrected .= $char;
        if ($in_bogus) {
          $line .= '</span>';
          $in_bogus = false;
        }
      }
      $line .= $char;
    }

    // end of line - check flag in case last char was bogus
    if ($in_bogus) {
      $line .= '</span>';
    }

    if (($repair) && ($needs_repair)) {
      // repair the alias
      $corrected = $corrected;
      // see http://api.drupal.org/api/drupal/includes%21database%21database.inc/function/db_update/7
      $status = db_update('url_alias')
                  ->fields(array(
                    'alias' => $corrected
                ))
                ->condition('pid', $pid, '=')
                ->execute();

      $repaired_nodes++;
    }

    $rows[] = array(array('data' => $node, 'class' => 'source'), array('data' => $line, 'class' => 'alias'));
    $line = "";
  }


  $output = '<p>' . $alias_count . ' nodes found</p>';
  if ($repair) {
    $output = '<p>' . format_plural($repaired_nodes, '1 node', '@count nodes') . ' repaired</p>';
    drupal_set_title('Repair Improper Path Aliases');
  }
  $output .= '<p class="final">' . count($improper) . ' improper strings found</p>';

  $output .= theme('table', array('header' => $header, 'rows' => $rows ));

  $module_path = drupal_get_path('module', 'cleanup_pathauto');
  drupal_add_css($module_path . '/cleanup_pathauto.css');
  $output = '<div class="cleanup-pathauto">' . $output . '</div>';

  return $output;
}


/**
 * @function: create lists of aliases and improper aliases found (internal only)
 *
 * @param $aliases    // reference to where to store list of all aliases
 * @param $improper   // reference to where to store list of improper aliases
 * @return count of aliases found
 */
function _cleanup_pathauto_get_improper_aliases(&$aliases, &$improper) {
  // types of nodes to check
  $cleanup_pathauto_check_nodes = preg_split("/\r\n/", variable_get('cleanup_pathauto_check_nodes', 'article'));

  // allowed characters (regex)
  $cleanup_pathauto_allowed_chars = variable_get('cleanup_pathauto_allowed_chars', '');

  $sql = <<<EOT
SELECT pid, source, alias FROM {url_alias} ua
ORDER BY ua.source
EOT;

  $result = db_query($sql);
  foreach ($result as $record) {
    $status = preg_match("/([^\/]+)\/(.+)/", $record->alias, $res);
    if ($status) {
      $path = $res[1];
      $arg = $res[2];

      if (in_array($path, $cleanup_pathauto_check_nodes)) {
        $index = $record->pid . '**' . $record->source;
        $aliases[$index] = $record->alias;
        if (preg_match($cleanup_pathauto_allowed_chars, $arg)) {
          $improper[$index] = $arg;
        }
      }
    }
  }

  return count($aliases);
}


/***
 * @param $alias
 * @param array $context
 *
 * implementation of hook_pathauto_alias_alter
 *
 * remove improper characters from aliases
 */
function cleanup_pathauto_pathauto_alias_alter(&$alias, array &$context) {
  if (strlen($alias) > 0) {
    // allowed characters (regex)
    $cleanup_pathauto_allowed_chars = variable_get('cleanup_pathauto_allowed_chars', '');
    $improper_chars = 0;    // # of improper chars found
    $corrected = '';

    // split string into chars; some could be multibyte
    $split = cleanup_pathauto_unistr_to_ords($alias);

    // walk alias string, looking for improper characters
    for ($i=0; $i < count($split); $i++) {
      $char = $split[$i];
      $bogus = (preg_match($cleanup_pathauto_allowed_chars, $char) || ($char > 255));
      if ($bogus) {
        // an improper char
        if (cleanup_pathauto_is_dash($char)) {
          // replace em or endash with hyphen
          $corrected .= '-';
        }
        else {
          // ignore all other improper chars
          $corrected .= '';
        }
        $improper_chars++;
      }
      else {
        // not an improper char
        $corrected .= chr($char);
      }
    }

    if ($improper_chars > 0) {
      $alias = $corrected;
      watchdog('cleanup_pathauto', ':improper_chars characters replaced while creating node alias %alias', array(':improper_chars' => $improper_chars, '%alias' => $corrected), WATCHDOG_NOTICE);
    }
  }
 }


/***
 * split string into array of chars; may be unicode
 *
 * see comment at http://www.php.net/manual/en/function.ord.php
 *
 *
 * @param $str
 * @param string $encoding
 * @return array
 */
function cleanup_pathauto_unistr_to_ords($str, $encoding = 'UTF-8'){
  // Turns a string of unicode characters into an array of ordinal values,
  // Even if some of those characters are multibyte.
  $str = mb_convert_encoding($str,"UCS-4BE",$encoding);
  $ords = array();

  // Visit each unicode character
  for($i = 0; $i < mb_strlen($str,"UCS-4BE"); $i++){
    // Now we have 4 bytes. Find their total
    // numeric value.
    $s2 = mb_substr($str,$i,1,"UCS-4BE");
    $val = unpack("N",$s2);
    $ords[] = $val[1];
  }
  return($ords);
}


/***
 * returns true if $char is an endash oremdash
 * @param $char
 * @return bool
 */
function cleanup_pathauto_is_dash($char) {
  if(($char == 8211) || ($char == 8212)) {
    return true;
  }

  return false;
}

/**
 * Update the URL aliases for an individual node.
 *
 * @param $node
 *   A node object.
 * @param $op
 *   Operation being performed on the node ('insert', 'update' or 'bulkupdate').
 * @param $options
 *   An optional array of additional options.
 */
function cleanup_pathauto_pathauto_node_update_alias(stdClass $node, $op, array $options = array()) {
  // Skip processing if the user has disabled pathauto for the node.
  if (isset($node->path['pathauto']) && empty($node->path['pathauto'])) {
    return;
  }

  $options += array(
    'language' => isset($node->language) ? $node->language : LANGUAGE_NONE,
  );

  // Skip processing if the node has no pattern.
  if (!pathauto_pattern_load_by_entity('node', $node->type, $options['language'])) {
    return;
  }

  module_load_include('inc', 'pathauto');
  $uri = entity_uri('node', $node);
  pathauto_create_alias('node', $op, $uri['path'], array('node' => $node), $node->type, $options['language']);
}


/***
 * repair improper aliases
 */
function cleanup_pathauto_repair() {
  return cleanup_pathauto_list(true);
}


